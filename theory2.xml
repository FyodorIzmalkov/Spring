Spring’s ApplicationContext object represents an instance of Spring container. 
Spring provides a few built-in implementations of ApplicationContext interface, 
like ClassPathXmlApplicationContext, FileSystemXmlApplicationContext, XmlWebApplicationContext, XmlPortletApplicationContext, and so on. 
The choice of the ApplicationContext implementation depends on how you have defined the configuration metadata (using XML, annotations or Java code), 
and the type of your application (standalone, web or portlet application). For instance, ClassPathXmlApplicationContext and FileSystemXmlApplicationContext 
classes are suitable for standalone applications in which configuration metadata is supplied in XML format, XmlWebApplicationContext is suitable for web applications 
in which the configuration metadata is supplied in XML format, AnnotationConfigWebApplicationContext is suitable for web applications in which configuration metadata 
is supplied through Java code, and so on. 

As MyBank application represents a standalone application, we can use either ClassPathXmlApplicationContext or FileSystemXmlApplicationContext class to
create an instance of Spring container. You should note that the ClassPathXmlApplicationContext class 
loads an application context XML file from the specified classpath location, and the FileSystemXmlApplicationContext 
class loads an application context XML file from the specified location on the filesystem. 

The application objects defined via <bean> elements are created and managed by the Spring container. 
You can access instances of these application objects by calling one of the getBean methods of the ApplicationContext interface. 

To use ‘programming to interfaces’ design approach in your Spring application, you need to ensure the following things: 
- the <bean> elements in the configuration metadata specify the concrete classes of the dependency 
- the dependent bean classes refer to the dependency interface instead of the concrete class of the dependency


The following bean definition for the FixedDepositDaoFactory class instructs Spring container to invoke FixedDepositDaoFactory’s 
getFixedDepositDao method to obtain an instance of FixedDepositJdbcDao class: 
<bean id="dao" 
    class="sample.spring.FixedDepositDaoFactory"
    factory-method="getFixedDepositDao">
    <constructor-arg index=”0” value="jdbc"/>
</bean> 

It is important to note that calling ApplicationContext’s getBean method to obtain dao bean 
(refer example listing 2-5) will result in invocation of the FixedDepositDaoFactory’s getFixedDepositDao factory method. 
This means that calling getBean("dao") returns the FixedDepositDao instance created by the getFixedDepositDao factory method,
 and not an instance of FixedDepositDaoFactory class. 

 Injecting object instances created by static factory method

<bean id="service" class="sample.spring.chapter02.bankapp.FixedDepositServiceImpl">
    <property name="fixedDepositDao" ref="dao" />
</bean>
 
 <bean 
 id="dao" 
 class="sample.spring.chapter02.basicapp.FixedDepositDaoFactory"
 factory-method="getFixedDepositDao">
 <constructor-arg index=”0” value="jdbc"/> 
 </bean>

 Configuration to invoke FixedDepositDaoFactory’s getFixedDepositDao method
 <bean id = "daoFactory" class = "sample.spring.chapter02.basicapp.FixedDepositDaoFactory" />

 <bean id = "dao" 
 factory-bean = "daoFactory"
  factory-method = "getFixedDepositDao"> 
  <constructor-arg index = "0" value = "jdbc" /> 
</bean>

<bean id="service" class="sample.spring.chapter02.bankapp.FixedDepositServiceImpl"><property name="fixedDepositDao" ref="dao" /> </bean>

In setter-based DI, <property> elements are used to specify bean dependencies. The <property> element is also used to pass configuration information (if any) required by the bean. 

We can set elements of type String as follows:

<bean id="emailMessageSender" class="EmailMessageSender">
    <property name="host" value="smtp.gmail.com"/>
    <property name="username" value="myusername"/>
    <property name="password" value="mypassword"/>
</bean> 

Configuration to invoke FixedDepositDaoFactory’s getFixedDepositDao method and set databaseInfo property of returned FixedDepositJdbcDao instance 

<bean id="daoFactory" class="FixedDepositDaoFactory" />

<bean id="dao" factory-bean="daoFactory" factory-method="getFixedDepositDao">
    <constructor-arg index="0" value="jdbc"/>
    <property name="databaseInfo" ref="databaseInfo"/>
</bean>

<bean id="databaseInfo" class="DatabaseInfo" /> 

Using constructor-arg:

<bean id="personalBankingService" class="PersonalBankingService">
    <constructor-arg index="0" ref="jmsMessageSender" />
    <constructor-arg index="1" ref="emailMessageSender" />
    <constructor-arg index="2" ref="webServiceInvoker" />
</bean>
    
<bean id="jmsMessageSender" class="JmsMessageSender">
.....
</bean>

<bean id="webServiceInvoker" class="WebServiceInvoker" />
.....
</bean>

In the above example listing, <constructor-arg> elements specify details of the constructor arguments passed to the PersonalBankingService instance. 
The index attribute specifies the index of the constructor argument. If the index attribute value is 0, 
it means that the <constructor-arg> element corresponds to the first constructor argument, and if the index attribute value is 1, 
it means that the <constructor-arg> element corresponds to the second constructor argument, and so on.

If a bean class requires both constructor- and setter-based DI mechanisms, you can use a combination of <constructor-arg> and <property> elements to inject dependencies. 

<bean id="dataSource" class="PersonalBankingService">
    <constructor-arg index="0" ref="jmsMessageSender" />
    <constructor-arg index="1" ref="emailMessageSender" />
    <property name="webServiceInvoker" ref="webServiceInvoker" />
</bean> 

You may want to specify the scope of a bean to control whether a shared instance of the bean is created (singleton scope), 
or a new bean instance is created every time the bean is requested (prototype scope) from the Spring container. 
The scope of a bean is defined by the scope attribute of the <bean> element. If the scope attribute is not specified, it means that the bean is a singleton-scoped bean.

If the scope attribute is not specified or the value of scope attribute is singleton, it means that the bean is singleton-scoped. 

In the above example listing, JUnit’s @BeforeClass annotation specifies that the init method is invoked before any of the test methods (that is, methods annotated with JUnit’s @Test annotation) in the class.
This means that @BeforeClass annotated method is invoked only once, and @Test annotated methods are executed only after the execution of @BeforeClass annotated method.

The scope of a singleton-scoped bean instance is limited to the Spring container instance.

Lazily initializing a singleton-scoped bean

<bean id="lazyBean" class="example.LazyBean" lazy-init="true"/> 

The <bean> element’s lazy-init attribute specifies whether the bean instance is created lazily or eagerly. If the value is true (as in case of the bean definition shown above),
 the bean instance is initialized by the Spring container when it receives the request for the bean for the first time. 

 A prototype-scoped bean is different from a singleton-scoped bean in the sense that the Spring container always returns a new instance of a prototype-scoped bean. 
 Another distinctive feature of prototype-scoped beans is that they are always lazily-initialized. 

 <bean id="FixedDepositDetails" class="sample.spring.chapter02.bankapp.domain.FixedDepositDetails" scope="prototype" /> 

 If a bean doesn’t maintain any conversational state (that is, it is stateless in nature), it should be defined as a singleton-scoped bean. 
 If a bean maintains conversational state, it should be defined as a prototype-scoped bean. 

 The following example listing shows that the personalBankingDao and fixedDepositDao bean definitions make use of bean definition inheritance: 

 <bean id="databaseOperations"class="sample.spring.chapter03.bankapp.utils.DatabaseOperations" />

 <bean id="daoTemplate" abstract="true">
    <property name="databaseOperations" ref="databaseOperations" />
</bean>

<bean id="FixedDepositDao" parent="daoTemplate" class="sample.spring.chapter03.bankapp.dao.FixedDepositDaoImpl" />
<bean id="personalBankingDao" parent="daoTemplate" class="sample.spring.chapter03.bankapp.dao.PersonalBankingDaoImpl" /> 

It is important to note that if you don’t specify the class attribute, you must define the parent bean definition as 
abstract so that Spring container doesn’t attempt to create a bean instance corresponding to it.

A child bean definition inherits the following configuration information from the parent bean definition: 
properties – specified via <property> elements
constructor arguments – specified via <constructor-arg> elements 
method overrides
initialization and destroy methods
factory methods – specified via factory-method attribute of <bean> element

When inheriting bean, you could extend or implement what you have been inhereting or make new methods (setters) and data fields for new class.

To inherit a factory and a factory method:

<bean id="controllerFactory"class="sample.spring.chapter03.bankapp.controller.ControllerFactory" />

<bean id="controllerTemplate" 
    factory-bean="controllerFactory" 
    factory-method="getController" 
    abstract="true">
</bean>

<bean id="fixedDepositController" parent="controllerTemplate">
    <constructor-arg index="0" value="fixedDepositController" />
    <property name="fixedDepositService" ref="fixedDepositService" />
</bean>

If a constructor argument is of simple Java type (like int, String, and so on), the <constructor-arg> 
element’s value attribute is used to specify the value of the constructor argument. 
If a constructor argument is a reference to a bean, you specify the name of the bean using the <constructor-arg> element’s ref attribute. 

If the <constructor-arg> element’s index attribute is not specified, Spring
container locates the constructor to be invoked by matching the types referenced by the <constructor-arg> 
elements with the argument types specified in the bean class’s constructor(s). 

We can specify a constructor-arg type:
<constructor-arg type="sample.spring.chapter03.bankapp.controller.BBean" ref="bBean"/>

Primitive types:

<constructor-arg type="boolean" value="true" />
<constructor-arg type="int" value="5" />
<constructor-arg type="long" value="200" />

Also we can use arg name:

<constructor-arg name="active" value="true" />
<constructor-arg name="numberOfRetrialAttempts" value="5" />
<constructor-arg name="timeout" value="200" />

Also we can use @ConstructorProperties
@ConstructorProperties({"webServiceUrl","active","timeout"});

If the constructor of the class corresponding to the parent bean definition is annotated with @ConstructorProperties annotation, 
the bean class corresponding to the child bean definition must also be annotated with @ConstructorProperties annotation. 

Map containing bean name as key and bean reference as value

<constructor-arg name="myExample">
<map>
    <entry>
        <key>
            <idref bean="sampleBean" />
        </key>
        <ref bean="sampleBean" />
    </entry>
</map>
</constructor-arg>

You can add a null value to collections of type Set and List using <null> element. The following example listing shows how to add a null value to a Set type constructor argument using <null> element: 
<set><value>Element 1</value><value>Element 2</value><null /></set>
In the above example listing, setWithNullElement constructor argument contains 3 elements: Element 1, Element 2 and null. 

Arrays:

<array><value>1</value><value>2</value></array>

To register property editors with the Spring container, you need to do the following
Create a class that implements Spring’s PropertyEditorRegistrar interface. This class is responsible for registering property editors with the Spring container. 
Configure the PropertyEditorRegistrar implementation as a Spring bean in the application context XML file. 
Configure Spring’s CustomEditorConfigurer special bean in the application context XML file, and provide it with reference to the PropertyEditorRegistrar implementation

To make bean definitions less verbose in application context XML files, Spring provides p and c namespaces to specify values for bean properties and constructor arguments, respectively.
 The p and c namespaces are alternatives to using <property> and <constructor-arg> elements, respectively. 

 To use p-namespace to set bean properties, specify bean properties as attributes of the <bean> element, and specify each bean property to be in the p-namespace. 

 <bean id="pnamespace" class="com.example.demo.Pnamespace" p:first="FIRST" p:second="SECOND"/>

 If a bean property is a reference to another bean, it is specified using the following syntax: 
 p:<property-name>-ref="<bean-reference>"

 To use c-namespace to supply values for constructor arguments, specify constructor arguments as attributes of the <bean> element, and specify each constructor argument to be in the c-namespace.
 xmlns:c="http://www.springframework.org/schema/c"

 <bean id="cnamespace" class="com.example.demo.Cnamespace" c:one="one" c:two="two" c:three="three" />

 It ll work only with debug flag (javac -g) , otherway use the indexes: c:_0="" c:_1="" etc.

 The <list> element of Spring’s util schema is used for creating objects of type java.util.List, as shown here: 
 xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd">

    <util:list id="listType" list-class="java.util.ArrayList">
    <value>A simple String value in list</value>
    <value>Another simple String value in list</value>
    </util:list> 

An alternative to using util schema’s <list> element is Spring’s ListFactoryBean – a factory that is used for creating instances of java.util.List and making them available as Spring beans. 
