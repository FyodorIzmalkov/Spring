Spring’s ApplicationContext object represents an instance of Spring container. 
Spring provides a few built-in implementations of ApplicationContext interface, 
like ClassPathXmlApplicationContext, FileSystemXmlApplicationContext, XmlWebApplicationContext, XmlPortletApplicationContext, and so on. 
The choice of the ApplicationContext implementation depends on how you have defined the configuration metadata (using XML, annotations or Java code), 
and the type of your application (standalone, web or portlet application). For instance, ClassPathXmlApplicationContext and FileSystemXmlApplicationContext 
classes are suitable for standalone applications in which configuration metadata is supplied in XML format, XmlWebApplicationContext is suitable for web applications 
in which the configuration metadata is supplied in XML format, AnnotationConfigWebApplicationContext is suitable for web applications in which configuration metadata 
is supplied through Java code, and so on. 

As MyBank application represents a standalone application, we can use either ClassPathXmlApplicationContext or FileSystemXmlApplicationContext class to
create an instance of Spring container. You should note that the ClassPathXmlApplicationContext class 
loads an application context XML file from the specified classpath location, and the FileSystemXmlApplicationContext 
class loads an application context XML file from the specified location on the filesystem. 

The application objects defined via <bean> elements are created and managed by the Spring container. 
You can access instances of these application objects by calling one of the getBean methods of the ApplicationContext interface. 

To use ‘programming to interfaces’ design approach in your Spring application, you need to ensure the following things: 
- the <bean> elements in the configuration metadata specify the concrete classes of the dependency 
- the dependent bean classes refer to the dependency interface instead of the concrete class of the dependency


The following bean definition for the FixedDepositDaoFactory class instructs Spring container to invoke FixedDepositDaoFactory’s 
getFixedDepositDao method to obtain an instance of FixedDepositJdbcDao class: 
<bean id="dao" 
    class="sample.spring.FixedDepositDaoFactory"
    factory-method="getFixedDepositDao">
    <constructor-arg index=”0” value="jdbc"/>
</bean> 

It is important to note that calling ApplicationContext’s getBean method to obtain dao bean 
(refer example listing 2-5) will result in invocation of the FixedDepositDaoFactory’s getFixedDepositDao factory method. 
This means that calling getBean("dao") returns the FixedDepositDao instance created by the getFixedDepositDao factory method,
 and not an instance of FixedDepositDaoFactory class. 

 Injecting object instances created by static factory method

<bean id="service" class="sample.spring.chapter02.bankapp.FixedDepositServiceImpl">
    <property name="fixedDepositDao" ref="dao" />
</bean>
 
 <bean 
 id="dao" 
 class="sample.spring.chapter02.basicapp.FixedDepositDaoFactory"
 factory-method="getFixedDepositDao">
 <constructor-arg index=”0” value="jdbc"/> 
 </bean>

 Configuration to invoke FixedDepositDaoFactory’s getFixedDepositDao method
 <bean id = "daoFactory" class = "sample.spring.chapter02.basicapp.FixedDepositDaoFactory" />

 <bean id = "dao" 
 factory-bean = "daoFactory"
  factory-method = "getFixedDepositDao"> 
  <constructor-arg index = "0" value = "jdbc" /> 
</bean>

<bean id="service" class="sample.spring.chapter02.bankapp.FixedDepositServiceImpl"><property name="fixedDepositDao" ref="dao" /> </bean>

In setter-based DI, <property> elements are used to specify bean dependencies. The <property> element is also used to pass configuration information (if any) required by the bean. 

We can set elements of type String as follows:

<bean id="emailMessageSender" class="EmailMessageSender">
    <property name="host" value="smtp.gmail.com"/>
    <property name="username" value="myusername"/>
    <property name="password" value="mypassword"/>
</bean> 

Configuration to invoke FixedDepositDaoFactory’s getFixedDepositDao method and set databaseInfo property of returned FixedDepositJdbcDao instance 

<bean id="daoFactory" class="FixedDepositDaoFactory" />

<bean id="dao" factory-bean="daoFactory" factory-method="getFixedDepositDao">
    <constructor-arg index="0" value="jdbc"/>
    <property name="databaseInfo" ref="databaseInfo"/>
</bean>

<bean id="databaseInfo" class="DatabaseInfo" /> 

Using constructor-arg:

<bean id="personalBankingService" class="PersonalBankingService">
    <constructor-arg index="0" ref="jmsMessageSender" />
    <constructor-arg index="1" ref="emailMessageSender" />
    <constructor-arg index="2" ref="webServiceInvoker" />
</bean>
    
<bean id="jmsMessageSender" class="JmsMessageSender">
.....
</bean>

<bean id="webServiceInvoker" class="WebServiceInvoker" />
.....
</bean>

In the above example listing, <constructor-arg> elements specify details of the constructor arguments passed to the PersonalBankingService instance. 
The index attribute specifies the index of the constructor argument. If the index attribute value is 0, 
it means that the <constructor-arg> element corresponds to the first constructor argument, and if the index attribute value is 1, 
it means that the <constructor-arg> element corresponds to the second constructor argument, and so on.

If a bean class requires both constructor- and setter-based DI mechanisms, you can use a combination of <constructor-arg> and <property> elements to inject dependencies. 

<bean id="dataSource" class="PersonalBankingService">
    <constructor-arg index="0" ref="jmsMessageSender" />
    <constructor-arg index="1" ref="emailMessageSender" />
    <property name="webServiceInvoker" ref="webServiceInvoker" />
</bean> 

You may want to specify the scope of a bean to control whether a shared instance of the bean is created (singleton scope), 
or a new bean instance is created every time the bean is requested (prototype scope) from the Spring container. 
The scope of a bean is defined by the scope attribute of the <bean> element. If the scope attribute is not specified, it means that the bean is a singleton-scoped bean.

If the scope attribute is not specified or the value of scope attribute is singleton, it means that the bean is singleton-scoped. 

In the above example listing, JUnit’s @BeforeClass annotation specifies that the init method is invoked before any of the test methods (that is, methods annotated with JUnit’s @Test annotation) in the class.
This means that @BeforeClass annotated method is invoked only once, and @Test annotated methods are executed only after the execution of @BeforeClass annotated method.

The scope of a singleton-scoped bean instance is limited to the Spring container instance.

Lazily initializing a singleton-scoped bean

<bean id="lazyBean" class="example.LazyBean" lazy-init="true"/> 

The <bean> element’s lazy-init attribute specifies whether the bean instance is created lazily or eagerly. If the value is true (as in case of the bean definition shown above),
 the bean instance is initialized by the Spring container when it receives the request for the bean for the first time. 

 A prototype-scoped bean is different from a singleton-scoped bean in the sense that the Spring container always returns a new instance of a prototype-scoped bean. 
 Another distinctive feature of prototype-scoped beans is that they are always lazily-initialized. 

 <bean id="FixedDepositDetails" class="sample.spring.chapter02.bankapp.domain.FixedDepositDetails" scope="prototype" /> 

 If a bean doesn’t maintain any conversational state (that is, it is stateless in nature), it should be defined as a singleton-scoped bean. 
 If a bean maintains conversational state, it should be defined as a prototype-scoped bean. 

 The following example listing shows that the personalBankingDao and fixedDepositDao bean definitions make use of bean definition inheritance: 

 <bean id="databaseOperations"class="sample.spring.chapter03.bankapp.utils.DatabaseOperations" />

 <bean id="daoTemplate" abstract="true">
    <property name="databaseOperations" ref="databaseOperations" />
</bean>

<bean id="FixedDepositDao" parent="daoTemplate" class="sample.spring.chapter03.bankapp.dao.FixedDepositDaoImpl" />
<bean id="personalBankingDao" parent="daoTemplate" class="sample.spring.chapter03.bankapp.dao.PersonalBankingDaoImpl" /> 

It is important to note that if you don’t specify the class attribute, you must define the parent bean definition as 
abstract so that Spring container doesn’t attempt to create a bean instance corresponding to it.

A child bean definition inherits the following configuration information from the parent bean definition: 
properties – specified via <property> elements
constructor arguments – specified via <constructor-arg> elements 
method overrides
initialization and destroy methods
factory methods – specified via factory-method attribute of <bean> element

When inheriting bean, you could extend or implement what you have been inhereting or make new methods (setters) and data fields for new class.

To inherit a factory and a factory method:

<bean id="controllerFactory"class="sample.spring.chapter03.bankapp.controller.ControllerFactory" />

<bean id="controllerTemplate" 
    factory-bean="controllerFactory" 
    factory-method="getController" 
    abstract="true">
</bean>

<bean id="fixedDepositController" parent="controllerTemplate">
    <constructor-arg index="0" value="fixedDepositController" />
    <property name="fixedDepositService" ref="fixedDepositService" />
</bean>

If a constructor argument is of simple Java type (like int, String, and so on), the <constructor-arg> 
element’s value attribute is used to specify the value of the constructor argument. 
If a constructor argument is a reference to a bean, you specify the name of the bean using the <constructor-arg> element’s ref attribute. 

If the <constructor-arg> element’s index attribute is not specified, Spring
container locates the constructor to be invoked by matching the types referenced by the <constructor-arg> 
elements with the argument types specified in the bean class’s constructor(s). 

We can specify a constructor-arg type:
<constructor-arg type="sample.spring.chapter03.bankapp.controller.BBean" ref="bBean"/>

Primitive types:

<constructor-arg type="boolean" value="true" />
<constructor-arg type="int" value="5" />
<constructor-arg type="long" value="200" />

Also we can use arg name:

<constructor-arg name="active" value="true" />
<constructor-arg name="numberOfRetrialAttempts" value="5" />
<constructor-arg name="timeout" value="200" />

Also we can use @ConstructorProperties
@ConstructorProperties({"webServiceUrl","active","timeout"});

If the constructor of the class corresponding to the parent bean definition is annotated with @ConstructorProperties annotation, 
the bean class corresponding to the child bean definition must also be annotated with @ConstructorProperties annotation. 

Map containing bean name as key and bean reference as value

<constructor-arg name="myExample">
<map>
    <entry>
        <key>
            <idref bean="sampleBean" />
        </key>
        <ref bean="sampleBean" />
    </entry>
</map>
</constructor-arg>

You can add a null value to collections of type Set and List using <null> element. The following example listing shows how to add a null value to a Set type constructor argument using <null> element: 
<set><value>Element 1</value><value>Element 2</value><null /></set>
In the above example listing, setWithNullElement constructor argument contains 3 elements: Element 1, Element 2 and null. 

Arrays:

<array><value>1</value><value>2</value></array>

To register property editors with the Spring container, you need to do the following
Create a class that implements Spring’s PropertyEditorRegistrar interface. This class is responsible for registering property editors with the Spring container. 
Configure the PropertyEditorRegistrar implementation as a Spring bean in the application context XML file. 
Configure Spring’s CustomEditorConfigurer special bean in the application context XML file, and provide it with reference to the PropertyEditorRegistrar implementation

To make bean definitions less verbose in application context XML files, Spring provides p and c namespaces to specify values for bean properties and constructor arguments, respectively.
 The p and c namespaces are alternatives to using <property> and <constructor-arg> elements, respectively. 

 To use p-namespace to set bean properties, specify bean properties as attributes of the <bean> element, and specify each bean property to be in the p-namespace. 

 <bean id="pnamespace" class="com.example.demo.Pnamespace" p:first="FIRST" p:second="SECOND"/>

 If a bean property is a reference to another bean, it is specified using the following syntax: 
 p:<property-name>-ref="<bean-reference>"

 To use c-namespace to supply values for constructor arguments, specify constructor arguments as attributes of the <bean> element, and specify each constructor argument to be in the c-namespace.
 xmlns:c="http://www.springframework.org/schema/c"

 <bean id="cnamespace" class="com.example.demo.Cnamespace" c:one="one" c:two="two" c:three="three" />

 It ll work only with debug flag (javac -g) , otherway use the indexes: c:_0="" c:_1="" etc.

 The <list> element of Spring’s util schema is used for creating objects of type java.util.List, as shown here: 
 xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd">

    <util:list id="listType" list-class="java.util.ArrayList">
    <value>A simple String value in list</value>
    <value>Another simple String value in list</value>
    </util:list> 

An alternative to using util schema’s <list> element is Spring’s ListFactoryBean – a factory that is used for creating instances of java.util.List and making them available as Spring beans. 


If a dependency of a bean is not shared by multiple beans, you can consider defining the dependency as an inner bean.
An inner bean is defined inside a <property> or <constructor-arg> element by using the <bean> element of Spring’s beans schema.

<bean id="service"class="sample.spring.chapter04.bankapp.service.FixedDepositServiceImpl">
<property name="fixedDepositDao">
<bean class="sample.spring.chapter04.bankapp.dao.FixedDepositDaoImpl" />
</property>
</bean> 

In the above example listing, the bean definition for the FixedDepositDaoImpl class is inside the <property> element of service bean.
An inner bean is always prototype-scoped; therefore, if the <bean> element corresponding to an inner bean definition specifies the scope attribute, then it is ignored by the Spring container.
It is important to note that an inner bean is anonymous in nature, and it’s not accessible to other beans (except the bean that contains the inner bean definition) in the Spring container. 
As in case of normal bean definition, you can use <property>, <constructor-arg>, and so on, elements inside the <bean> element of the inner bean definition. 

The order in which beans are created is also decided based on the inter-dependencies of beans.

Implicit dependency problem:

- change order in xml file
- use <bean> element’s depends-on attribute to explicitly specify

<bean id="service" class="sample.spring.chapter04.bankapp.service.FixedDepositServiceImpl" depends-on="eventSenderSelectorService">.....</bean>

If a bean has multiple implicit dependencies, you can specify ids or names of all those dependencies as the value of depends-on attribute, as shown here: 
<bean id="abean" ..... depends-on="bBean, cBean">

It is important to note that the depends-on attribute is not inherited by child bean definitions.

A singleton-scoped bean (and its singleton-scoped dependencies) is created when the ApplicationContext instance is created. And, a prototype-scoped bean (and its prototype-scoped dependencies) is created each time ApplicationContext’s 
getBean method is invoked to obtain the prototype-scoped bean. 

It is important to note that even if setter-based DI was used to inject the prototype-scoped customerRequestDetails dependency of the customerRequestService bean, 
the Spring container would have called the setter method only once during the lifetime of the customerRequestService bean. This means that irrespective of whether 
setter- or constructor-based DI is used, a singleton bean is created and configured only once during it’s lifetime. 

if a prototype-scoped bean X is dependent on another prototype-scoped bean Y, 
Spring container will create a new instance of X and Y each time you request bean X from the Spring container.

Obtaining new instances of prototype beans inside singleton beans 

Spring container creates instance of a singleton-scoped bean only once; therefore, 
the singleton-scoped bean holds reference to the same prototype-scoped bean instance during its lifetime.

A singleton-scoped bean’s methods can retrieve a new instance of their prototype-scoped dependency from the Spring container using any one of the following approaches: 
- make the singleton-scoped bean’s class implement Spring’s ApplicationContextAware interface 
- use the <lookup-method> element of Spring’s beans schema 
- use the <replaced-method> element of Spring’s beans schema 

Spring’s ApplicationContextAware interface is implemented by beans that require access to the ApplicationContext instance in which they are running. 
ApplicationContextAware interface defines a single method, setApplicationContext, which provides the implementing beans with an instance of the ApplicationContext object. 
ApplicationContextAware interface is a lifecycle interface, which means that the
Spring container calls the beans implementing the ApplicationContextAware interface at appropriate times during their lifetime.

If a bean class defines a bean lookup method whose return type represents a bean, the <lookup-method> element instructs the Spring container to provide implementation for this method.
The <lookup-method> element’s bean attribute specifies the name of the bean to be looked-up and returned by the method implementation, and the name attribute specifies the name of the method whose implementation is to be provided by the Spring container.
The use of <lookup-method> element to instruct the Spring container to provide implementation for a bean lookup method is referred to as a ‘Method Injection techinique’ because the <lookup-method> element injects a bean lookup method implementation into the bean class. 

<bean id="customerRequestService"class="sample.spring.chapter04.bankapp.service.CustomerRequestServiceImpl">
    <constructor-arg name="customerRequestDao" ref="customerRequestDao" />
    <lookup-method bean="customerRequestDetails" name="getCustomerRequestDetails"/>
</bean>

<bean id="customerRequestDetails"class="sample.spring.chapter04.bankapp.domain.CustomerRequestDetails"scope="prototype" /> 

The value of <lookup-method> element’s bean attribute is customerRequestDetails, which means that the implementation of getCustomerRequestDetails method retrieves a bean with id (or name) as customerRequestDetails from the Spring container and returns it to the calling method.
As the implementation of the bean lookup method is provided by the Spring container, some restrictions apply to the signature of the bean lookup methods. 
For instance, the bean lookup method must be defined as public or protected, and it must not accept any arguments.
As the bean class containing the bean lookup method is subclassed at runtime by the Spring container to provide the implementation for the bean lookup method, 
the bean class and the bean lookup method must not be defined as final. 

Instead of using <lookup-method> element, you can consider using <replaced-method> element of Spring’s beans schema to perform method injection. 
The <replaced-method> element allows you to replace any arbitrary method in a bean class with a different implementation.
The overriding method is provided by the class that implements Spring’s MethodReplacer interface.
public class MyMethodReplacer implements MethodReplacer, ApplicationContextAware {
public Object reimplement(Object obj, Method method, Object[] args)
throws Throwable {
return applicationContext.getBean((String) args[0]);}

@Override
public void setApplicationContext(ApplicationContext applicationContext)throws BeansException 
{this.applicationContext = applicationContext;} }

The reimplement method accepts the following arguments: 
·        Object obj – identifies the object whose method we are overriding. In our example scenario, the obj object is the CustomerRequestServiceImpl object. 
·        Method method – identifies the bean class’s method that is overridden by the reimplement method. In our example scenario, this is CustomerRequestServiceImpl’s getMyBean method. 
·        Object[] args – identifies arguments passed to the method that we are overriding. In our example scenario, args represents the arguments passed to the CustomerRequestServiceImpl’s getMyBean method. In example listing 4-20, args[0] in the reimplement method refers the bean name argument passed to the CustomerRequestServiceImpl’s getMyBean method.

<bean id="customerRequestService" class="sample.spring.chapter04.bankapp.service.CustomerRequestServiceImpl">
    <constructor-arg name="customerRequestDao" ref="customerRequestDao" />
    <replaced-method name="getMyBean" replacer="methodReplacer" />
</bean>

<bean id="methodReplacer"class="sample.spring.chapter04.bankapp.service.MyMethodReplacer" /> 

It is important to note that you can use <replaced-method> element to replace an abstract or concrete method of a bean class with a different method implementation. 
For instance, we could have defined getMyBean method as an abstract method and used the <replaced-method> element in the same way as described in this section. 

To uniquely identify the bean method to be overridden, the <replaced-method> element uses <arg-type> sub-elements to specify method argument types.
<bean id="mybean" class="MyBean">
    <replaced-method name="perform " replacer=".....">
        <arg-type>java.lang.String</arg-type>
        <arg-type>java.lang.String</arg-type>
    </replaced-method>
</bean> 

Let’s now look at Spring’s autowiring feature that saves you the effort of specifying bean dependencies in the application context XML file.
Autowiring dependencies 
In Spring, you have the option to either explicitly specify bean dependencies using <property> and <constructor-arg> elements or let Spring automatically resolve bean dependencies.
 The process in which dependencies are automatically resolved by Spring is referred to as ‘autowiring’. 

 The <bean> element’s autowire attribute specifies how a bean’s dependencies are automatically resolved by Spring. The autowire attribute can take any one of the following values: default, byName, byType, constructor and no.
 You should note that the <bean> element’s autowire attribute is not inherited by child bean definitions. 

BY TYPE
 If you specify autowire attribute’s value as byType, Spring autowires bean properties based on their type. 
 For instance, if a bean A defines a property of type X, Spring finds a bean of type X in the ApplicationContext and injects it into bean A.

 <bean id="customerRegistrationService" class="sample.spring.chapter04.bankapp.service.CustomerRegistrationServiceImpl" scope="prototype" autowire="byType" />
 
 <bean id="customerRegistrationDetails" class="sample.spring.chapter04.bankapp.domain.CustomerRegistrationDetails" scope="prototype" />
 
 <bean id="customerRegistrationDao" class="sample.spring.chapter04.bankapp.dao.CustomerRegistrationDaoImpl" /> 

 It may happen that Spring doesn’t find any bean registered with the ApplicationContext whose type matches the property type. 
 In such cases, no exception is thrown and the bean property is not set.

 If Spring finds multiple beans in the ApplicationContext that match the property type, an exception is thrown.

 If you specify autowire attribute’s value as constructor, Spring autowires bean class’s constructor arguments based on their type. 
 For instance, if bean A’s constructor accepts arguments of type X and Y, Spring finds beans of types X and Y in the ApplicationContext 
 and injects them as arguments to bean A’s constructor.

 <bean id="customerRequestService" class="sample.spring.chapter04.bankapp.service.CustomerRequestServiceImpl" autowire="constructor"></bean>
 
 <bean id="customerRequestDetails" class="sample.spring.chapter04.bankapp.domain.CustomerRequestDetails" scope="prototype" />
 
 <bean id="customerRequestDao" class="sample.spring.chapter04.bankapp.dao.CustomerRequestDaoImpl" />

 If you specify autowire attribute’s value as byName, Spring autowires bean properties based on their names. For instance, if a bean A defines a property named x, Spring finds a bean named x in the ApplicationContext and injects it into bean A.

 If you specify autowire attribute’s value as default or no, autowiring feature is disabled for the bean. 
 As Spring’s default behavior is to use no autowiring for beans, specifying autowire attribute’s value as default means no autowiring will be performed for the bean.
  You can explicitly specify that a bean must not use Spring’s autowiring feature by specifying autowire attribute’s value as no. 
  <bean id="customerRegistrationService_" class="sample.spring.chapter04.bankapp.service.CustomerRegistrationServiceImpl" scope="prototype" autowire="no" /> 

  The default behavior of the Spring container is to make beans available for autowiring. You can make a bean unavailable to other beans for autowiring purposes by setting autowire-candidate attribute’s value to false. 
  <bean id="accountStatementDao" class="sample.spring.chapter04.bankapp.dao.AccountStatementDaoImpl" autowire-candidate="false" /> 

  In the above example listing, default-autowire-candidates value is set to *Dao, which means that beans whose names end with Dao 
  (like customerRequestDao and customerRegistrationDao beans) will be available for autowiring purposes. 
  If a bean name doesn’t match the pattern specified by the default-autowire-candidates attribute (like customerRequestDetails bean),
   you can still make it available for autowiring purposes by setting the autowire-candidate attribute of the corresponding <bean> element to true. 

   <beans default-autowire-candidates="*Dao" >..... </beans>

   We saw that autowiring feature saves the effort to explicitly specify bean dependencies using <property> and <constructor-arg> elements. The downsides of using autowiring feature are: 
   ·        You can’t use autowiring to set properties or constructor arguments that are of simple Java types (like int, long, boolean, String, Date, and so on). You can autowire arrays, typed collections and maps if the autowire attribute’s value is set to byType or constructor. 
   ·        As bean dependencies are automatically resolved by Spring, it results in hiding the overall structure of the application. If you use <property> and
<constructor-arg> elements to specify bean dependencies, it results in explicitly documenting the overall structure of the application.
 You can easily understand and maintain an application in which bean dependencies are explicitly documented. 
For this reason, it is not recommended to use autowiring in large applications.

Initialize and destroy methods

<bean id="myFixedDepositDao" class="sample.spring.chapter05.bankapp.dao.FixedDepositDaoImpl" init-method="initializeDbConnection" destroy-method="releaseDbConnection" /> 
The above example listing shows that the <bean> element corresponding to the FixedDepositDaoImpl class specifies initializeDbConnection and releaseDbConnection as the values of init-method and destroy-method attributes, respectively. 
It is important to note that the initialization and destruction methods specified by the init-method and destroy-method attributes of <bean> element must not accept any arguments, but can be defined to throw exceptions. 
how you can make Spring gracefully destroy singleton-scoped bean instances by calling the cleanup method specified by the <bean> element’s destroy-method attribute. 

Spring’s AbstractionApplicationContext class implements ApplicationContext interface and defines a registerShutdownHook method that registers a shutdown hook with the JVM. The shutdown hook is responsible for closing the ApplicationContext when the JVM is shutdown.
In case of prototype-scoped beans, destroy-method attribute is ignored by the Spring container.
Lifecycles of prototype- and singleton-scoped beans are same, except that the Spring container will not call the cleanup method (specified by the destroy-init attribute) of the prototype-scoped bean instance. 
You can use the default-init-method and default-destroy-method attributes of <beans> element to specify default initialization and destruction methods

<beans ..... default-init-method="initialize" default-destroy-method="release"><bean id="A" class="....." init-method="initializeService" /><bean id="B" class="....." /> </beans> 

Instead of using init-method and destroy-method attributes of <bean> element to specify custom initialization and destruction methods, you can use Spring’s InitializingBean and DisposableBean lifecycle interfaces. 
A bean class in Spring can set a method as an initialization method by annotating it with @PostConstruct, and set a method as a destruction method by annotating it with @PreDestroy annotation. 
@PostConstruct and @PreDestroy annotations to identify initialization and destruction methods.

@PostConstructpublic void initializeDbConnection() {logger.info("FixedDepositDaoImplís initializeDbConnection method invoked");connection = DatabaseConnection.getInstance();}
@PreDestroypublic void releaseDbConnection() {logger.info("FixedDepositDaoImpl's releaseDbConnection method invoked");connection.releaseConnection();}

To use @PostConstruct and @PreDestroy annotations in your application, you need to configure Spring’s CommonAnnotationBeanPostProcessor class in the application context XML file
<bean
		class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>

BeanPostProcessor interface defines the following methods: 
Object postProcessBeforeInitialization(Object bean, String beanName) – this method is invoked before the initialization method of a bean instance is invoked
Object postProcessAfterInitialization(Object bean, String beanName) – this method is invoked after the initialization method of a bean instance is invoked 

You configure a BeanPostProcessor implementation in the application context XML file like any other Spring bean.

In a Spring application, you may want to verify that a bean instance is configured correctly before it is injected into dependent beans or accessed by other objects in the application.
If the setter-method for a bean property is annotated with Spring’s @Required annotation, Spring’s RequiredAnnotationBeanPostProcessor (a BeanPostProcessor implementation) checks if the bean property is configured in the application context XML file. 
If you have defined RequiredAnnotationBeanPostProcessor in the application context XML file, the RequiredAnnotationBeanPostProcessor 
will check if you have specified a <property> element (or used p-namespace) to set the value of FixedDepositDao property. 
If you haven’t configured the FixedDepositDao property in the bean definition for the FixedDepositServiceImpl class in 
the application context XML file, it’ll result in an exception.

RequiredAnnotationBeanPostProcessor only ensures that a bean property is configured in the bean definition. It doesn’t ensure that the configured property value is correct.

DestructionAwareBeanPostProcessor  
interact with a bean instance before it is destroyed, configure a bean that implements Spring’s DestructionAwareBeanPostProcessor interface in the application context XML file. DestructionAwareBeanPostProcessor is a sub-interface of BeanPostProcessor interface
void postProcessBeforeDestruction(Object bean, String beanName);

A BeanFactoryPostProcessor is executed after bean definitions are loaded by the Spring container, but before any bean instance is created.

As FixedDepositSerivceImpl class is annotated with @Service annotation, FixedDepositServiceImpl class represents a Spring component. 
@Service annotation accepts a value attribute that specifies the name with which the component is registered as a bean with the Spring container. 
For instance, FixedDepositServiceImpl class is registered with Spring container as a bean with the name FixedDepositService. 
The value attribute serves the same purpose as the <bean> element’s id attribute. 

@Service(value="FixedDepositService") public class FixedDepositServiceImpl implements FixedDepositService { ..... } 

Like @Service annotation, @Component, @Repository and @Controller annotations specify the name of the component via value attribute.
You can
specify the name of a Spring component without explicitly specifying the value attribute. This means that @Service(value="FixedDepositService") 
is same as @Service("FixedDepositService").
If you don’t specify a name for the component, Spring assumes name of the component is same as the name of the component class.

You enable classpath scanning feature of Spring by using the <component-scan> element of Spring’s context schema. 

xmlns:context="http://www.springframework.org/schema/context"
<context:component-scan base-package="sample.spring"/> 

he <component-scan> element’s base-package attribute specifies comma-separated list of packages that should be searched for Spring components. 
As the base-package attribute’s value is sample.spring, Spring components are searched inside sample.spring package and its sub-packages.

Also we can use include and exclude filters:

<context:component-scan base-package="sample.example"><context:include-filter type="annotation" expression="example.annotation.MyAnnotation"/><context:exclude-filter type="regex" expression=".*Details"/>   </context:component-scan> 
The <exclude-filter> and <include-filter> elements define a type attribute that specifies the strategy used for filtering component classes, and the expression attribute specifies the corresponding filter expression.


@Autowired - autowiring dependencies by type 
Spring’s @Autowired annotation provides the same functionality as the Spring’s autowiring feature that we discussed in chapter 4, 
but @Autowired annotation offers a more cleaner and flexible approach to autowiring bean dependencies.

@Autowired
private AccountStatementDao accountStatementDao;

In the above example listing, the accountStatementDao field (of type AccountStatementDao) is annotated with @Autowired annotation.
When an instance of AccountStatementServiceImpl is created, Spring’s
AutowiredAnnotationBeanPostProcessor (a BeanPostProcessor implementation) is responsible for autowiring accountStatementDao field.

If a method is annotated with @Autowired annotation, the arguments of the method are autowired. 
As obtainCustomerRegistrationDetails method is annotated with @Autowired annotation, its CustomerRegistrationDetails argument is autowired by type. 
It is important to note that an @Autowired annotated method need not be public. 

If a constructor is annotated with @Autowired annotation, the arguments of the constructor are autowired.

When using the @Autowired annotation, exception is thrown if a bean matching the required type is not found.

@Autowired’s required attribute specifies whether it is mandatory or optional to autowire dependencies. 
If you set @Autowired’s required attribute value to false, autowiring of dependencies is considered optional.

A component class can define multiple @Autowired annotated constructors with required attribute’s value set to false. In such a case, one of the constructors will be invoked by Spring to create an instance of the component class.
@Autowired(required=false)

The constructor with the largest number of satisfied dependencies is chosen.

@Qualifier – autowiring dependencies by name 

You can use Spring’s @Qualifier annotation along with @Autowired annotation to autowire dependencies by name. 
The @Qualifier annotation can be used at field-level, method-parameter-level and constructor-argument-level. 

@Autowired
@Qualifier(value="myFixedDepositDao")
private FixedDepositDao myFixedDepositDao;
n the above example listing, myFixedDepositDao field is annotated with @Autowired and @Qualifier annotations. @Qualifier annotation’s value attribute specifies the name of the bean to be assigned to the myFixedDepositDao field. 

Spring first finds autowiring candidates ‘by type’ for the fields, constructors and methods that are annotated with @Autowired annotation.
 Then, Spring uses the bean name specified by @Qualifier annotation to locate a unique bean from the list of autowiring candidates.

 @Qualifier(value="myFixedDepositDao") is same as @Qualifier("myFixedDepositDao"); you don’t need to use the value attribute to specify the name of the bean to be autowired. 

 Qualifier as a method parameter:

 @Autowiredpublic Sample(@Qualifier("aBean") ABean bean) { .... }

 JSR 330’s @Inject and @Named annotations 

 @Autowired and @Inject annotations have the same semantics; they are used for autowiring dependencies by type.
  Like @Autowired annotation, @Inject can be used at method-level, constructor-level and field-level.
  Dependency injection of constructors is performed first, followed by fields, and then methods.

  If @Named annotation is used at the type-level, it acts like Spring’s @Component annotation.
  And, if @Named annotation is used at the method-parameter-level or constructor-argument-level, it acts like Spring’s @Qualifier annotation.

  Spring supports autowiring ‘by name’ of fields and methods via JSR 250’s @Resource annotation.
  @Resource annotation’s name attribute specifies the name of the bean to be autowired. 
  It is important to note that you can’t use @Resource annotation for autowiring constructor arguments. 
  when you use @Resource annotation, type of the field (or setter method argument) to be autowired is not taken into consideration by Spring. 
  When you use Autowired and Qualifier it searches first by-type and then by-name;

  You specify the scope (prototype or singleton) of a Spring component using Spring’s @Scope annotation.
  If you want a Spring component to be prototype-scoped, you have to specify so via @Scope annotation.

  The @Scope annotation accepts a value attribute that specifies the scope of the component. 
  You can set value attribute’s value to prototype or singleton to indicate whether the component is singleton-scoped or prototype-scoped, 
  or you can set value attribute’s value to ConfigurableBeanFactory’s SCOPE_SINGLETON (value is singleton) or SCOPE_PROTOTYPE (value is prototype) constants. 

  By default, singleton-scoped Spring components are eagerly initialized, that is, they are instantiated when the Spring container is created. 
  If you want a singleton-scoped component to be lazily created, annotate the component class
of a singleton-scoped component with @Lazy annotation. 
@Lazy(value=true) @Component 

You specify implicit bean dependencies using @DependsOn annotation.
@DependsOn(value = {"beanA", "beanB"}) 
In the above example listing, @DependsOn annotation on the Sample class instructs the Spring container to create beanA and beanB beans before creating an instance of Sample class. 

If multiple autowiring candidates are available for a dependency, @Primary annotation designates a bean as a primary candidate for autowiring.

@Primary @Component public class Sample { ..... } 

As Spring components are not defined in the application context XML file, Spring’s @Value annotation 
is used to serve the same purpose as the value attribute of <property> and <constructor-arg> elements. 
You should note that the @Value annotation can be used at field-level, method-level, method-parameter-level and constructor-argument-level. 

The above example listing shows that the @Value annotation specifies a value that has the syntax #{<spel-expression>}. 
The SpEL expression specified by @Value annotation is processed by a BeanPostProcessor. 
The SpEL expressions can make use of <beanName>.<field or property or method> format to obtain its value. 
For instance, #{configuration.environment} means obtain value of environment property of bean named configuration, 
and # {configuration.getCountry()} means invoke getCountry method of bean named configuration. 

Spring’s Validator interface is part of Spring Validation API that allows you to perform validation of objects. You can use the Validator interface for performing validation of objects in any of the application layers. 
For instance, you can use the Validator interface to validate objects in the web layer as well as in the persistence layer. 

The Validator interface defines supports and validate methods. The supports method checks if the supplied object instance (represented by the clazz attribute) can be validated.

Specifying constraints using JSR 303 annotations 

@NotNull, @Min, @Max, @NotBlank and @Size are some of the annotations defined by JSR 303 Bean Validation API.
 The above example listing shows that by using JSR 303 annotations FixedDepositDetails class clearly specifies the constraints that apply on its fields.
  On the other hand, if you are using Spring Validation API to validate an object, constraint information is contained in the Validator implementation (refer example listing 6-24). 

Programmatically configuring Spring beans using @Configuration and @Bean annotations 
You can use @Configuration and @Bean annotations to programmatically configure Spring beans. 
If you annotate a class with @Configuration annotation, it indicates that the class contains @Bean annotated methods that return bean instances meant 
to be registered with the Spring container.

@Configuration public class BankAppConfiguration {.....
@Bean(name = "customerRegistrationService")@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)public CustomerRegistrationService customerRegistrationService() {return new CustomerRegistrationServiceImpl();}

BankAppConfiguration class defines @Bean annotated methods that return bean instances. @Bean’s name attribute specifies the name with which the returned bean instance is registered with the Spring container. @Scope annotation specifies the scope (singleton or prototype) of the returned bean instance.
It is important to note that @Bean annotated methods may also be annotated with @Lazy, @DependsOn, @Primary and @Scope annotations.
If you are using an @Configuration annotated class as the source of beans, you need to create an instance of AnnotationConfigApplicationContext class (another implementation of ApplicationContext interface) to represent the Spring container. 

Spring @Bean annotation tells that a method produces a bean to be managed by the Spring container. It is a method-level annotation. 
During Java configuration (@Configuration), the method is executed and its return value is registered as a bean within a BeanFactory.

Database interaction using Spring

Spring’s JDBC module simplifies interaction with data sources by taking care of lower level details of opening and closing connections, 
managing transactions, processing exceptions, and so on.

Spring’s JDBC module defines multiple classes that simplify database interaction.

JdbcTemplate class takes care of managing Connection, Statement and ResultSet objects, catching JDBC exceptions and translating them into easily understandable exceptions (like IncorrectResultSetColumnCountException and CannotGetJdbcConnectionException), performing batch operations, and so on. 
An application developer only needs to provide SQL to the JdbcTemplate class, and extract results after the SQL is executed. 

Spring’s NamedParameterJdbcTemplate is a wrapper around JdbcTemplate instance that allows you to use named parameters in the SQL statement rather than using ? . 

Spring’s ORM module provides integration with Hibernate, Java Persistence API (JPA), MyBatis, and Java Data Objects (JDO).

If you want to use JPA’s EntityManager in your application’s DAOs for database interaction, configure Spring’s LocalContainerEntityManagerFactoryBean instead of org.springframework.orm.hibernate4.LocalSessionFactoryBean. 
The dataSource property specifies reference to a bean of type javax.sql.DataSource. 
The packagesToScan property specifies the package(s) under which Spring looks for persistent classes. 
For instance, the above example listing specifies that if a persistent class is annotated with JPA’s @Entity annotation, 
and is located inside sample.spring package (or its sub-packages), it is automatically detected by org.springframework.orm.hibernate4. LocalSessionFactoryBean.

Spring Framework supports both programmatic and declarative transaction management. 
In programmatic transaction management, Spring’s transaction management abstraction is used to explicitly start, end and commit transactions. 
In declarative transaction management, you annotate methods that execute within a transaction with Spring’s @Transactional annotation. 
You can programmatically manage transactions by using Spring’s TransactionTemplate class or by using an implementation of Spring’s PlatformTransactionManager interface. 
TransactionTemplate class simplifies transaction management by taking care of initiating and committing transactions.
You only need to provide an implementation of Spring’s TransactionCallback interface that contains the code to be executed within a transaction. 

When using PlatformTransactionManager implementation, you are required to explicitly initiate and commit (or roll back) transactions. 
For this reason, it is recommended to use TransactionTemplate instead of directly using a PlatformTransactionManager implementation. 

On the other hand, declarative transaction management requires you to only annotate methods or classes with Spring’s @Transactional annotation. 
If you want to execute a method within a transaction, annotate the method with @Transactional annotation. 
If you want to execute all the methods of a class within a transaction, annotate the class with @Transactional annotation. 

Instead of using @Transactional annotation for declarative transaction management, you can use Spring’s tx schema elements to identify transactional methods. 
As using Spring’s tx schema results in verbose application context XML file, we’ll be only looking at using @Transactional annotation for declarative transaction management. 

You enable declarative transaction management using <annotation-driven> element of Spring’s tx schema. The following example listing shows the <annotation-driven> element’s usage in ch07-bankapp-jdbc project: 


Creating JDBC Application
There are following six steps involved in building a JDBC application −

Import the packages: Requires that you include the packages containing the JDBC classes needed for database programming. Most often, using import java.sql.* will suffice.

Register the JDBC driver: Requires that you initialize a driver so you can open a communication channel with the database.

Open a connection: Requires using the DriverManager.getConnection() method to create a Connection object, which represents a physical connection with the database.

Execute a query: Requires using an object of type Statement for building and submitting an SQL statement to the database.

Extract data from result set: Requires that you use the appropriate ResultSet.getXXX() method to retrieve the data from the result set.

Clean up the environment: Requires explicitly closing all database resources versus relying on the JVM's garbage collection.



JDBC drivers implement the defined interfaces in the JDBC API, for interacting with your database server.
For example, using JDBC drivers enable you to open database connections and to interact with it by sending SQL or database commands then receiving results with Java.

After you've installed the appropriate driver, it is time to establish a database connection using JDBC.

The programming involved to establish a JDBC connection is fairly simple. Here are these simple four steps −

Import JDBC Packages: Add import statements to your Java program to import required classes in your Java code.

Register JDBC Driver: This step causes the JVM to load the desired driver implementation into memory so it can fulfill your JDBC requests.
You must register the driver in your program before you use it. 
Registering the driver is the process by which the Oracle driver's class file is loaded into the memory, so it can be utilized as an implementation of the JDBC interfaces.

The most common approach to register a driver is to use Java's Class.forName() method, 
to dynamically load the driver's class file into memory, which automatically registers it. 
This method is preferable because it allows you to make the driver registration configurable and portable.

try {
   Class.forName("oracle.jdbc.driver.OracleDriver");
}
catch(ClassNotFoundException ex) {
   System.out.println("Error: unable to load driver class!");
   System.exit(1);
}

The second approach you can use to register a driver, is to use the static DriverManager.registerDriver() method.
You should use the registerDriver() method if you are using a non-JDK compliant JVM, such as the one provided by Microsoft.

The following example uses registerDriver() to register the Oracle driver −
try {
   Driver myDriver = new oracle.jdbc.driver.OracleDriver();
   DriverManager.registerDriver( myDriver );
}
catch(ClassNotFoundException ex) {
   System.out.println("Error: unable to load driver class!");
   System.exit(1);
}

You need to do this registration only once in your program. You can register a driver in one of two ways.

Database URL Formulation: This is to create a properly formatted address that points to the database to which you wish to connect.
After you've loaded the driver, you can establish a connection using the DriverManager.getConnection() method. 
For easy reference, let me list the three overloaded DriverManager.getConnection() methods −
getConnection(String url)
getConnection(String url, Properties prop)
getConnection(String url, String user, String password)
Here each form requires a database URL. A database URL is an address that points to your database.

RDBMS	JDBC driver name	URL format
MySQL	com.mysql.jdbc.Driver	jdbc:mysql://hostname/ databaseName
ORACLE	oracle.jdbc.driver.OracleDriver	jdbc:oracle:thin:@hostname:port Number:databaseName
DB2	COM.ibm.db2.jdbc.net.DB2Driver	jdbc:db2:hostname:port Number/databaseName
Sybase	com.sybase.jdbc.SybDriver	jdbc:sybase:Tds:hostname: port Number/databaseName

The most commonly used form of getConnection() requires you to pass a database URL, a username, and a password:

Assuming you are using Oracle's thin driver, you'll specify a host:port:databaseName value for the database portion of the URL.

If you have a host at TCP/IP address 192.0.0.1 with a host name of amrood, and your Oracle listener is configured to listen on port 1521, and your database name is EMP, then complete database URL would be −

jdbc:oracle:thin:@amrood:1521:EMP

Now you have to call getConnection() method with appropriate username and password to get a Connection object as follows −

String URL = "jdbc:oracle:thin:@amrood:1521:EMP";
String USER = "username";
String PASS = "password"
Connection conn = DriverManager.getConnection(URL, USER, PASS);

Using Only a Database URL
A second form of the DriverManager.getConnection( ) method requires only a database URL −

DriverManager.getConnection(String url);
However, in this case, the database URL includes the username and password and has the following general form −

jdbc:oracle:driver:username/password@database
So, the above connection can be created as follows −

String URL = "jdbc:oracle:thin:username/password@amrood:1521:EMP";
Connection conn = DriverManager.getConnection(URL);

A third form of the DriverManager.getConnection( ) method requires a database URL and a Properties object −

DriverManager.getConnection(String url, Properties info);
A Properties object holds a set of keyword-value pairs. It is used to pass driver properties to the driver during a call to the getConnection() method.

To make the same connection made by the previous examples, use the following code −

import java.util.*;

String URL = "jdbc:oracle:thin:@amrood:1521:EMP";
Properties info = new Properties( );
info.put( "user", "username" );
info.put( "password", "password" );

Connection conn = DriverManager.getConnection(URL, info);

At the end of your JDBC program, it is required explicitly to close all the connections to the database to end each database session. However, if you forget, Java's garbage collector will close the connection when it cleans up stale objects.

Relying on the garbage collection, especially in database programming, is a very poor programming practice. You should make a habit of always closing the connection with the close() method associated with connection object.

To ensure that a connection is closed, you could provide a 'finally' block in your code. A finally block always executes, regardless of an exception occurs or not.

To close the above opened connection, you should call close() method as follows −

conn.close();
Explicitly closing a connection conserves DBMS resources, which will make your database administrator happy.

Create Connection Object: Finally, code a call to the DriverManager object's getConnection( ) method to establish actual database connection.

Once a connection is obtained we can interact with the database. The JDBC Statement, CallableStatement, 
and PreparedStatement interfaces define the methods and properties that enable you to send SQL or PL/SQL commands and receive data from your database.

Statement	Use this for general-purpose access to your database. Useful when you are using static SQL statements at runtime. The Statement interface cannot accept parameters.
PreparedStatement	Use this when you plan to use the SQL statements many times. The PreparedStatement interface accepts input parameters at runtime.
CallableStatement	Use this when you want to access the database stored procedures. The CallableStatement interface can also accept runtime input parameters.

Before you can use a Statement object to execute a SQL statement, you need to create one using the Connection object's createStatement( ) method, as in the following example −
Statement stmt = null;
try {
   stmt = conn.createStatement( );
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   . . .
}

Once you've created a Statement object, you can then use it to execute an SQL statement with one of its three execute methods.
boolean execute (String SQL): Returns a boolean value of true if a ResultSet object can be retrieved; otherwise, it returns false. Use this method to execute SQL DDL statements or when you need to use truly dynamic SQL.int executeUpdate (String SQL): Returns the number of rows affected by the execution of the SQL statement. Use this method to execute SQL statements for which you expect to get a number of rows affected - for example, an INSERT, UPDATE, or DELETE statement.
ResultSet executeQuery (String SQL): Returns a ResultSet object. Use this method when you expect to get a result set, as you would with a SELECT statement.

A simple call to the close() method will do the job. If you close the Connection object first, it will close the Statement object as well. However, you should always explicitly close the Statement object to ensure proper cleanup.

PreparedStatement pstmt = null;
try {
   String SQL = "Update Employees SET age = ? WHERE id = ?";
   pstmt = conn.prepareStatement(SQL);
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   . . .
}
All parameters in JDBC are represented by the ? symbol, which is known as the parameter marker. You must supply values for every parameter before executing the SQL statement.

String sql = "UPDATE Employees set age=? WHERE id=?";
stmt = conn.prepareStatement(sql);
      
      //Bind values into the parameters.
      stmt.setInt(1, 35);  // This would set age
      stmt.setInt(2, 102); // This would set ID
      
      // Let us update age of the record with ID = 102;
      int rows = stmt.executeUpdate();

      Three types of parameters exist: IN, OUT, and INOUT. The PreparedStatement object only uses the IN parameter. The CallableStatement object can use all the three.

Here are the definitions of each −

Parameter	Description
IN	A parameter whose value is unknown when the SQL statement is created. You bind values to IN parameters with the setXXX() methods.
OUT	A parameter whose value is supplied by the SQL statement it returns. You retrieve values from theOUT parameters with the getXXX() methods.
INOUT	A parameter that provides both input and output values. You bind variables with the setXXX() methods and retrieve values with the getXXX() methods.

CallableStatement cstmt = null;
try {
   String SQL = "{call getEmpName (?, ?)}";
   cstmt = conn.prepareCall (SQL);
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   . . .
}

The following example illustrates the use of a commit and rollback object −

try{
   //Assume a valid connection object conn
   conn.setAutoCommit(false);
   Statement stmt = conn.createStatement();
   
   String SQL = "INSERT INTO Employees  " +
                "VALUES (106, 20, 'Rita', 'Tez')";
   stmt.executeUpdate(SQL);  
   //Submit a malformed SQL statement that breaks
   String SQL = "INSERTED IN Employees  " +
                "VALUES (107, 22, 'Sita', 'Singh')";
   stmt.executeUpdate(SQL);
   // If there is no error.
   conn.commit();
}catch(SQLException se){
   // If there is any error.
   conn.rollback();
}