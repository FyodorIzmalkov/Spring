Spring’s ApplicationContext object represents an instance of Spring container. 
Spring provides a few built-in implementations of ApplicationContext interface, 
like ClassPathXmlApplicationContext, FileSystemXmlApplicationContext, XmlWebApplicationContext, XmlPortletApplicationContext, and so on. 
The choice of the ApplicationContext implementation depends on how you have defined the configuration metadata (using XML, annotations or Java code), 
and the type of your application (standalone, web or portlet application). For instance, ClassPathXmlApplicationContext and FileSystemXmlApplicationContext 
classes are suitable for standalone applications in which configuration metadata is supplied in XML format, XmlWebApplicationContext is suitable for web applications 
in which the configuration metadata is supplied in XML format, AnnotationConfigWebApplicationContext is suitable for web applications in which configuration metadata 
is supplied through Java code, and so on. 

As MyBank application represents a standalone application, we can use either ClassPathXmlApplicationContext or FileSystemXmlApplicationContext class to
create an instance of Spring container. You should note that the ClassPathXmlApplicationContext class 
loads an application context XML file from the specified classpath location, and the FileSystemXmlApplicationContext 
class loads an application context XML file from the specified location on the filesystem. 

The application objects defined via <bean> elements are created and managed by the Spring container. 
You can access instances of these application objects by calling one of the getBean methods of the ApplicationContext interface. 

To use ‘programming to interfaces’ design approach in your Spring application, you need to ensure the following things: 
- the <bean> elements in the configuration metadata specify the concrete classes of the dependency 
- the dependent bean classes refer to the dependency interface instead of the concrete class of the dependency


The following bean definition for the FixedDepositDaoFactory class instructs Spring container to invoke FixedDepositDaoFactory’s 
getFixedDepositDao method to obtain an instance of FixedDepositJdbcDao class: 
<bean id="dao" 
    class="sample.spring.FixedDepositDaoFactory"
    factory-method="getFixedDepositDao">
    <constructor-arg index=”0” value="jdbc"/>
</bean> 

It is important to note that calling ApplicationContext’s getBean method to obtain dao bean 
(refer example listing 2-5) will result in invocation of the FixedDepositDaoFactory’s getFixedDepositDao factory method. 
This means that calling getBean("dao") returns the FixedDepositDao instance created by the getFixedDepositDao factory method,
 and not an instance of FixedDepositDaoFactory class. 

 Injecting object instances created by static factory method

<bean id="service" class="sample.spring.chapter02.bankapp.FixedDepositServiceImpl">
    <property name="fixedDepositDao" ref="dao" />
</bean>
 
 <bean 
 id="dao" 
 class="sample.spring.chapter02.basicapp.FixedDepositDaoFactory"
 factory-method="getFixedDepositDao">
 <constructor-arg index=”0” value="jdbc"/> 
 </bean>

 Configuration to invoke FixedDepositDaoFactory’s getFixedDepositDao method
 <bean id = "daoFactory" class = "sample.spring.chapter02.basicapp.FixedDepositDaoFactory" />

 <bean id = "dao" 
 factory-bean = "daoFactory"
  factory-method = "getFixedDepositDao"> 
  <constructor-arg index = "0" value = "jdbc" /> 
</bean>

<bean id="service" class="sample.spring.chapter02.bankapp.FixedDepositServiceImpl"><property name="fixedDepositDao" ref="dao" /> </bean>

In setter-based DI, <property> elements are used to specify bean dependencies. The <property> element is also used to pass configuration information (if any) required by the bean. 

We can set elements of type String as follows:

<bean id="emailMessageSender" class="EmailMessageSender">
    <property name="host" value="smtp.gmail.com"/>
    <property name="username" value="myusername"/>
    <property name="password" value="mypassword"/>
</bean> 

Configuration to invoke FixedDepositDaoFactory’s getFixedDepositDao method and set databaseInfo property of returned FixedDepositJdbcDao instance 

<bean id="daoFactory" class="FixedDepositDaoFactory" />

<bean id="dao" factory-bean="daoFactory" factory-method="getFixedDepositDao">
    <constructor-arg index="0" value="jdbc"/>
    <property name="databaseInfo" ref="databaseInfo"/>
</bean>

<bean id="databaseInfo" class="DatabaseInfo" /> 

Using constructor-arg:

<bean id="personalBankingService" class="PersonalBankingService">
    <constructor-arg index="0" ref="jmsMessageSender" />
    <constructor-arg index="1" ref="emailMessageSender" />
    <constructor-arg index="2" ref="webServiceInvoker" />
</bean>
    
<bean id="jmsMessageSender" class="JmsMessageSender">
.....
</bean>

<bean id="webServiceInvoker" class="WebServiceInvoker" />
.....
</bean>

In the above example listing, <constructor-arg> elements specify details of the constructor arguments passed to the PersonalBankingService instance. 
The index attribute specifies the index of the constructor argument. If the index attribute value is 0, 
it means that the <constructor-arg> element corresponds to the first constructor argument, and if the index attribute value is 1, 
it means that the <constructor-arg> element corresponds to the second constructor argument, and so on.

If a bean class requires both constructor- and setter-based DI mechanisms, you can use a combination of <constructor-arg> and <property> elements to inject dependencies. 

<bean id="dataSource" class="PersonalBankingService">
    <constructor-arg index="0" ref="jmsMessageSender" />
    <constructor-arg index="1" ref="emailMessageSender" />
    <property name="webServiceInvoker" ref="webServiceInvoker" />
</bean> 

You may want to specify the scope of a bean to control whether a shared instance of the bean is created (singleton scope), 
or a new bean instance is created every time the bean is requested (prototype scope) from the Spring container. 
The scope of a bean is defined by the scope attribute of the <bean> element. If the scope attribute is not specified, it means that the bean is a singleton-scoped bean.

If the scope attribute is not specified or the value of scope attribute is singleton, it means that the bean is singleton-scoped. 

In the above example listing, JUnit’s @BeforeClass annotation specifies that the init method is invoked before any of the test methods (that is, methods annotated with JUnit’s @Test annotation) in the class.
This means that @BeforeClass annotated method is invoked only once, and @Test annotated methods are executed only after the execution of @BeforeClass annotated method.

The scope of a singleton-scoped bean instance is limited to the Spring container instance.

Lazily initializing a singleton-scoped bean

<bean id="lazyBean" class="example.LazyBean" lazy-init="true"/> 

The <bean> element’s lazy-init attribute specifies whether the bean instance is created lazily or eagerly. If the value is true (as in case of the bean definition shown above),
 the bean instance is initialized by the Spring container when it receives the request for the bean for the first time. 

 A prototype-scoped bean is different from a singleton-scoped bean in the sense that the Spring container always returns a new instance of a prototype-scoped bean. 
 Another distinctive feature of prototype-scoped beans is that they are always lazily-initialized. 

 <bean id="FixedDepositDetails" class="sample.spring.chapter02.bankapp.domain.FixedDepositDetails" scope="prototype" /> 

 If a bean doesn’t maintain any conversational state (that is, it is stateless in nature), it should be defined as a singleton-scoped bean. 
 If a bean maintains conversational state, it should be defined as a prototype-scoped bean. 

 The following example listing shows that the personalBankingDao and fixedDepositDao bean definitions make use of bean definition inheritance: 

 <bean id="databaseOperations"class="sample.spring.chapter03.bankapp.utils.DatabaseOperations" />

 <bean id="daoTemplate" abstract="true">
    <property name="databaseOperations" ref="databaseOperations" />
</bean>

<bean id="FixedDepositDao" parent="daoTemplate" class="sample.spring.chapter03.bankapp.dao.FixedDepositDaoImpl" />
<bean id="personalBankingDao" parent="daoTemplate" class="sample.spring.chapter03.bankapp.dao.PersonalBankingDaoImpl" /> 

It is important to note that if you don’t specify the class attribute, you must define the parent bean definition as 
abstract so that Spring container doesn’t attempt to create a bean instance corresponding to it.

A child bean definition inherits the following configuration information from the parent bean definition: 
properties – specified via <property> elements
constructor arguments – specified via <constructor-arg> elements 
method overrides
initialization and destroy methods
factory methods – specified via factory-method attribute of <bean> element

When inheriting bean, you could extend or implement what you have been inhereting or make new methods (setters) and data fields for new class.

To inherit a factory and a factory method:

<bean id="controllerFactory"class="sample.spring.chapter03.bankapp.controller.ControllerFactory" />

<bean id="controllerTemplate" 
    factory-bean="controllerFactory" 
    factory-method="getController" 
    abstract="true">
</bean>

<bean id="fixedDepositController" parent="controllerTemplate">
    <constructor-arg index="0" value="fixedDepositController" />
    <property name="fixedDepositService" ref="fixedDepositService" />
</bean>

If a constructor argument is of simple Java type (like int, String, and so on), the <constructor-arg> 
element’s value attribute is used to specify the value of the constructor argument. 
If a constructor argument is a reference to a bean, you specify the name of the bean using the <constructor-arg> element’s ref attribute. 

If the <constructor-arg> element’s index attribute is not specified, Spring
container locates the constructor to be invoked by matching the types referenced by the <constructor-arg> 
elements with the argument types specified in the bean class’s constructor(s). 

We can specify a constructor-arg type:
<constructor-arg type="sample.spring.chapter03.bankapp.controller.BBean" ref="bBean"/>

Primitive types:

<constructor-arg type="boolean" value="true" />
<constructor-arg type="int" value="5" />
<constructor-arg type="long" value="200" />

Also we can use arg name:

<constructor-arg name="active" value="true" />
<constructor-arg name="numberOfRetrialAttempts" value="5" />
<constructor-arg name="timeout" value="200" />

Also we can use @ConstructorProperties
@ConstructorProperties({"webServiceUrl","active","timeout"});

If the constructor of the class corresponding to the parent bean definition is annotated with @ConstructorProperties annotation, 
the bean class corresponding to the child bean definition must also be annotated with @ConstructorProperties annotation. 

Map containing bean name as key and bean reference as value

<constructor-arg name="myExample">
<map>
    <entry>
        <key>
            <idref bean="sampleBean" />
        </key>
        <ref bean="sampleBean" />
    </entry>
</map>
</constructor-arg>

You can add a null value to collections of type Set and List using <null> element. The following example listing shows how to add a null value to a Set type constructor argument using <null> element: 
<set><value>Element 1</value><value>Element 2</value><null /></set>
In the above example listing, setWithNullElement constructor argument contains 3 elements: Element 1, Element 2 and null. 

Arrays:

<array><value>1</value><value>2</value></array>

To register property editors with the Spring container, you need to do the following
Create a class that implements Spring’s PropertyEditorRegistrar interface. This class is responsible for registering property editors with the Spring container. 
Configure the PropertyEditorRegistrar implementation as a Spring bean in the application context XML file. 
Configure Spring’s CustomEditorConfigurer special bean in the application context XML file, and provide it with reference to the PropertyEditorRegistrar implementation

To make bean definitions less verbose in application context XML files, Spring provides p and c namespaces to specify values for bean properties and constructor arguments, respectively.
 The p and c namespaces are alternatives to using <property> and <constructor-arg> elements, respectively. 

 To use p-namespace to set bean properties, specify bean properties as attributes of the <bean> element, and specify each bean property to be in the p-namespace. 

 <bean id="pnamespace" class="com.example.demo.Pnamespace" p:first="FIRST" p:second="SECOND"/>

 If a bean property is a reference to another bean, it is specified using the following syntax: 
 p:<property-name>-ref="<bean-reference>"

 To use c-namespace to supply values for constructor arguments, specify constructor arguments as attributes of the <bean> element, and specify each constructor argument to be in the c-namespace.
 xmlns:c="http://www.springframework.org/schema/c"

 <bean id="cnamespace" class="com.example.demo.Cnamespace" c:one="one" c:two="two" c:three="three" />

 It ll work only with debug flag (javac -g) , otherway use the indexes: c:_0="" c:_1="" etc.

 The <list> element of Spring’s util schema is used for creating objects of type java.util.List, as shown here: 
 xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd">

    <util:list id="listType" list-class="java.util.ArrayList">
    <value>A simple String value in list</value>
    <value>Another simple String value in list</value>
    </util:list> 

An alternative to using util schema’s <list> element is Spring’s ListFactoryBean – a factory that is used for creating instances of java.util.List and making them available as Spring beans. 


If a dependency of a bean is not shared by multiple beans, you can consider defining the dependency as an inner bean.
An inner bean is defined inside a <property> or <constructor-arg> element by using the <bean> element of Spring’s beans schema.

<bean id="service"class="sample.spring.chapter04.bankapp.service.FixedDepositServiceImpl">
<property name="fixedDepositDao">
<bean class="sample.spring.chapter04.bankapp.dao.FixedDepositDaoImpl" />
</property>
</bean> 

In the above example listing, the bean definition for the FixedDepositDaoImpl class is inside the <property> element of service bean.
An inner bean is always prototype-scoped; therefore, if the <bean> element corresponding to an inner bean definition specifies the scope attribute, then it is ignored by the Spring container.
It is important to note that an inner bean is anonymous in nature, and it’s not accessible to other beans (except the bean that contains the inner bean definition) in the Spring container. 
As in case of normal bean definition, you can use <property>, <constructor-arg>, and so on, elements inside the <bean> element of the inner bean definition. 

The order in which beans are created is also decided based on the inter-dependencies of beans.

Implicit dependency problem:

- change order in xml file
- use <bean> element’s depends-on attribute to explicitly specify

<bean id="service" class="sample.spring.chapter04.bankapp.service.FixedDepositServiceImpl" depends-on="eventSenderSelectorService">.....</bean>

If a bean has multiple implicit dependencies, you can specify ids or names of all those dependencies as the value of depends-on attribute, as shown here: 
<bean id="abean" ..... depends-on="bBean, cBean">

It is important to note that the depends-on attribute is not inherited by child bean definitions.

A singleton-scoped bean (and its singleton-scoped dependencies) is created when the ApplicationContext instance is created. And, a prototype-scoped bean (and its prototype-scoped dependencies) is created each time ApplicationContext’s 
getBean method is invoked to obtain the prototype-scoped bean. 

It is important to note that even if setter-based DI was used to inject the prototype-scoped customerRequestDetails dependency of the customerRequestService bean, 
the Spring container would have called the setter method only once during the lifetime of the customerRequestService bean. This means that irrespective of whether 
setter- or constructor-based DI is used, a singleton bean is created and configured only once during it’s lifetime. 

if a prototype-scoped bean X is dependent on another prototype-scoped bean Y, 
Spring container will create a new instance of X and Y each time you request bean X from the Spring container.

Obtaining new instances of prototype beans inside singleton beans 

Spring container creates instance of a singleton-scoped bean only once; therefore, 
the singleton-scoped bean holds reference to the same prototype-scoped bean instance during its lifetime.

A singleton-scoped bean’s methods can retrieve a new instance of their prototype-scoped dependency from the Spring container using any one of the following approaches: 
- make the singleton-scoped bean’s class implement Spring’s ApplicationContextAware interface 
- use the <lookup-method> element of Spring’s beans schema 
- use the <replaced-method> element of Spring’s beans schema 

Spring’s ApplicationContextAware interface is implemented by beans that require access to the ApplicationContext instance in which they are running. 
ApplicationContextAware interface defines a single method, setApplicationContext, which provides the implementing beans with an instance of the ApplicationContext object. 
ApplicationContextAware interface is a lifecycle interface, which means that the
Spring container calls the beans implementing the ApplicationContextAware interface at appropriate times during their lifetime.

If a bean class defines a bean lookup method whose return type represents a bean, the <lookup-method> element instructs the Spring container to provide implementation for this method.
The <lookup-method> element’s bean attribute specifies the name of the bean to be looked-up and returned by the method implementation, and the name attribute specifies the name of the method whose implementation is to be provided by the Spring container.
The use of <lookup-method> element to instruct the Spring container to provide implementation for a bean lookup method is referred to as a ‘Method Injection techinique’ because the <lookup-method> element injects a bean lookup method implementation into the bean class. 

<bean id="customerRequestService"class="sample.spring.chapter04.bankapp.service.CustomerRequestServiceImpl">
    <constructor-arg name="customerRequestDao" ref="customerRequestDao" />
    <lookup-method bean="customerRequestDetails" name="getCustomerRequestDetails"/>
</bean>

<bean id="customerRequestDetails"class="sample.spring.chapter04.bankapp.domain.CustomerRequestDetails"scope="prototype" /> 

The value of <lookup-method> element’s bean attribute is customerRequestDetails, which means that the implementation of getCustomerRequestDetails method retrieves a bean with id (or name) as customerRequestDetails from the Spring container and returns it to the calling method.
As the implementation of the bean lookup method is provided by the Spring container, some restrictions apply to the signature of the bean lookup methods. 
For instance, the bean lookup method must be defined as public or protected, and it must not accept any arguments.
As the bean class containing the bean lookup method is subclassed at runtime by the Spring container to provide the implementation for the bean lookup method, 
the bean class and the bean lookup method must not be defined as final. 

Instead of using <lookup-method> element, you can consider using <replaced-method> element of Spring’s beans schema to perform method injection. 
The <replaced-method> element allows you to replace any arbitrary method in a bean class with a different implementation.
The overriding method is provided by the class that implements Spring’s MethodReplacer interface.
public class MyMethodReplacer implements MethodReplacer, ApplicationContextAware {
public Object reimplement(Object obj, Method method, Object[] args)
throws Throwable {
return applicationContext.getBean((String) args[0]);}

@Override
public void setApplicationContext(ApplicationContext applicationContext)throws BeansException 
{this.applicationContext = applicationContext;} }

The reimplement method accepts the following arguments: 
·        Object obj – identifies the object whose method we are overriding. In our example scenario, the obj object is the CustomerRequestServiceImpl object. 
·        Method method – identifies the bean class’s method that is overridden by the reimplement method. In our example scenario, this is CustomerRequestServiceImpl’s getMyBean method. 
·        Object[] args – identifies arguments passed to the method that we are overriding. In our example scenario, args represents the arguments passed to the CustomerRequestServiceImpl’s getMyBean method. In example listing 4-20, args[0] in the reimplement method refers the bean name argument passed to the CustomerRequestServiceImpl’s getMyBean method.

<bean id="customerRequestService" class="sample.spring.chapter04.bankapp.service.CustomerRequestServiceImpl">
    <constructor-arg name="customerRequestDao" ref="customerRequestDao" />
    <replaced-method name="getMyBean" replacer="methodReplacer" />
</bean>

<bean id="methodReplacer"class="sample.spring.chapter04.bankapp.service.MyMethodReplacer" /> 

It is important to note that you can use <replaced-method> element to replace an abstract or concrete method of a bean class with a different method implementation. 
For instance, we could have defined getMyBean method as an abstract method and used the <replaced-method> element in the same way as described in this section. 

To uniquely identify the bean method to be overridden, the <replaced-method> element uses <arg-type> sub-elements to specify method argument types.
<bean id="mybean" class="MyBean">
    <replaced-method name="perform " replacer=".....">
        <arg-type>java.lang.String</arg-type>
        <arg-type>java.lang.String</arg-type>
    </replaced-method>
</bean> 

Let’s now look at Spring’s autowiring feature that saves you the effort of specifying bean dependencies in the application context XML file.
Autowiring dependencies 
In Spring, you have the option to either explicitly specify bean dependencies using <property> and <constructor-arg> elements or let Spring automatically resolve bean dependencies.
 The process in which dependencies are automatically resolved by Spring is referred to as ‘autowiring’. 

 The <bean> element’s autowire attribute specifies how a bean’s dependencies are automatically resolved by Spring. The autowire attribute can take any one of the following values: default, byName, byType, constructor and no.
 You should note that the <bean> element’s autowire attribute is not inherited by child bean definitions. 

BY TYPE
 If you specify autowire attribute’s value as byType, Spring autowires bean properties based on their type. 
 For instance, if a bean A defines a property of type X, Spring finds a bean of type X in the ApplicationContext and injects it into bean A.

 <bean id="customerRegistrationService" class="sample.spring.chapter04.bankapp.service.CustomerRegistrationServiceImpl" scope="prototype" autowire="byType" />
 
 <bean id="customerRegistrationDetails" class="sample.spring.chapter04.bankapp.domain.CustomerRegistrationDetails" scope="prototype" />
 
 <bean id="customerRegistrationDao" class="sample.spring.chapter04.bankapp.dao.CustomerRegistrationDaoImpl" /> 

 It may happen that Spring doesn’t find any bean registered with the ApplicationContext whose type matches the property type. 
 In such cases, no exception is thrown and the bean property is not set.

 If Spring finds multiple beans in the ApplicationContext that match the property type, an exception is thrown.

 If you specify autowire attribute’s value as constructor, Spring autowires bean class’s constructor arguments based on their type. 
 For instance, if bean A’s constructor accepts arguments of type X and Y, Spring finds beans of types X and Y in the ApplicationContext 
 and injects them as arguments to bean A’s constructor.

 <bean id="customerRequestService" class="sample.spring.chapter04.bankapp.service.CustomerRequestServiceImpl" autowire="constructor"></bean>
 
 <bean id="customerRequestDetails" class="sample.spring.chapter04.bankapp.domain.CustomerRequestDetails" scope="prototype" />
 
 <bean id="customerRequestDao" class="sample.spring.chapter04.bankapp.dao.CustomerRequestDaoImpl" />

 If you specify autowire attribute’s value as byName, Spring autowires bean properties based on their names. For instance, if a bean A defines a property named x, Spring finds a bean named x in the ApplicationContext and injects it into bean A.

 If you specify autowire attribute’s value as default or no, autowiring feature is disabled for the bean. 
 As Spring’s default behavior is to use no autowiring for beans, specifying autowire attribute’s value as default means no autowiring will be performed for the bean.
  You can explicitly specify that a bean must not use Spring’s autowiring feature by specifying autowire attribute’s value as no. 
  <bean id="customerRegistrationService_" class="sample.spring.chapter04.bankapp.service.CustomerRegistrationServiceImpl" scope="prototype" autowire="no" /> 

  The default behavior of the Spring container is to make beans available for autowiring. You can make a bean unavailable to other beans for autowiring purposes by setting autowire-candidate attribute’s value to false. 
  <bean id="accountStatementDao" class="sample.spring.chapter04.bankapp.dao.AccountStatementDaoImpl" autowire-candidate="false" /> 

  In the above example listing, default-autowire-candidates value is set to *Dao, which means that beans whose names end with Dao 
  (like customerRequestDao and customerRegistrationDao beans) will be available for autowiring purposes. 
  If a bean name doesn’t match the pattern specified by the default-autowire-candidates attribute (like customerRequestDetails bean),
   you can still make it available for autowiring purposes by setting the autowire-candidate attribute of the corresponding <bean> element to true. 

   <beans default-autowire-candidates="*Dao" >..... </beans>

   We saw that autowiring feature saves the effort to explicitly specify bean dependencies using <property> and <constructor-arg> elements. The downsides of using autowiring feature are: 
   ·        You can’t use autowiring to set properties or constructor arguments that are of simple Java types (like int, long, boolean, String, Date, and so on). You can autowire arrays, typed collections and maps if the autowire attribute’s value is set to byType or constructor. 
   ·        As bean dependencies are automatically resolved by Spring, it results in hiding the overall structure of the application. If you use <property> and
<constructor-arg> elements to specify bean dependencies, it results in explicitly documenting the overall structure of the application.
 You can easily understand and maintain an application in which bean dependencies are explicitly documented. 
For this reason, it is not recommended to use autowiring in large applications.

Initialize and destroy methods

<bean id="myFixedDepositDao" class="sample.spring.chapter05.bankapp.dao.FixedDepositDaoImpl" init-method="initializeDbConnection" destroy-method="releaseDbConnection" /> 
The above example listing shows that the <bean> element corresponding to the FixedDepositDaoImpl class specifies initializeDbConnection and releaseDbConnection as the values of init-method and destroy-method attributes, respectively. 
It is important to note that the initialization and destruction methods specified by the init-method and destroy-method attributes of <bean> element must not accept any arguments, but can be defined to throw exceptions. 
how you can make Spring gracefully destroy singleton-scoped bean instances by calling the cleanup method specified by the <bean> element’s destroy-method attribute. 

Spring’s AbstractionApplicationContext class implements ApplicationContext interface and defines a registerShutdownHook method that registers a shutdown hook with the JVM. The shutdown hook is responsible for closing the ApplicationContext when the JVM is shutdown.
In case of prototype-scoped beans, destroy-method attribute is ignored by the Spring container.
Lifecycles of prototype- and singleton-scoped beans are same, except that the Spring container will not call the cleanup method (specified by the destroy-init attribute) of the prototype-scoped bean instance. 
You can use the default-init-method and default-destroy-method attributes of <beans> element to specify default initialization and destruction methods

<beans ..... default-init-method="initialize" default-destroy-method="release"><bean id="A" class="....." init-method="initializeService" /><bean id="B" class="....." /> </beans> 

Instead of using init-method and destroy-method attributes of <bean> element to specify custom initialization and destruction methods, you can use Spring’s InitializingBean and DisposableBean lifecycle interfaces. 
A bean class in Spring can set a method as an initialization method by annotating it with @PostConstruct, and set a method as a destruction method by annotating it with @PreDestroy annotation. 
@PostConstruct and @PreDestroy annotations to identify initialization and destruction methods.

@PostConstructpublic void initializeDbConnection() {logger.info("FixedDepositDaoImplís initializeDbConnection method invoked");connection = DatabaseConnection.getInstance();}
@PreDestroypublic void releaseDbConnection() {logger.info("FixedDepositDaoImpl's releaseDbConnection method invoked");connection.releaseConnection();}

To use @PostConstruct and @PreDestroy annotations in your application, you need to configure Spring’s CommonAnnotationBeanPostProcessor class in the application context XML file
<bean
		class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>

BeanPostProcessor interface defines the following methods: 
Object postProcessBeforeInitialization(Object bean, String beanName) – this method is invoked before the initialization method of a bean instance is invoked
Object postProcessAfterInitialization(Object bean, String beanName) – this method is invoked after the initialization method of a bean instance is invoked 

You configure a BeanPostProcessor implementation in the application context XML file like any other Spring bean.

In a Spring application, you may want to verify that a bean instance is configured correctly before it is injected into dependent beans or accessed by other objects in the application.
If the setter-method for a bean property is annotated with Spring’s @Required annotation, Spring’s RequiredAnnotationBeanPostProcessor (a BeanPostProcessor implementation) checks if the bean property is configured in the application context XML file. 
If you have defined RequiredAnnotationBeanPostProcessor in the application context XML file, the RequiredAnnotationBeanPostProcessor 
will check if you have specified a <property> element (or used p-namespace) to set the value of FixedDepositDao property. 
If you haven’t configured the FixedDepositDao property in the bean definition for the FixedDepositServiceImpl class in 
the application context XML file, it’ll result in an exception.

RequiredAnnotationBeanPostProcessor only ensures that a bean property is configured in the bean definition. It doesn’t ensure that the configured property value is correct.

DestructionAwareBeanPostProcessor  
interact with a bean instance before it is destroyed, configure a bean that implements Spring’s DestructionAwareBeanPostProcessor interface in the application context XML file. DestructionAwareBeanPostProcessor is a sub-interface of BeanPostProcessor interface
void postProcessBeforeDestruction(Object bean, String beanName);

A BeanFactoryPostProcessor is executed after bean definitions are loaded by the Spring container, but before any bean instance is created.

As FixedDepositSerivceImpl class is annotated with @Service annotation, FixedDepositServiceImpl class represents a Spring component. 
@Service annotation accepts a value attribute that specifies the name with which the component is registered as a bean with the Spring container. 
For instance, FixedDepositServiceImpl class is registered with Spring container as a bean with the name FixedDepositService. 
The value attribute serves the same purpose as the <bean> element’s id attribute. 

@Service(value="FixedDepositService") public class FixedDepositServiceImpl implements FixedDepositService { ..... } 

Like @Service annotation, @Component, @Repository and @Controller annotations specify the name of the component via value attribute.
You can
specify the name of a Spring component without explicitly specifying the value attribute. This means that @Service(value="FixedDepositService") is same as @Service("FixedDepositService").
If you don’t specify a name for the component, Spring assumes name of the component is same as the name of the component class.

You enable classpath scanning feature of Spring by using the <component-scan> element of Spring’s context schema. 

xmlns:context="http://www.springframework.org/schema/context"
<context:component-scan base-package="sample.spring"/> 

he <component-scan> element’s base-package attribute specifies comma-separated list of packages that should be searched for Spring components. 
As the base-package attribute’s value is sample.spring, Spring components are searched inside sample.spring package and its sub-packages.

Also we can use include and exclude filters:

<context:component-scan base-package="sample.example"><context:include-filter type="annotation" expression="example.annotation.MyAnnotation"/><context:exclude-filter type="regex" expression=".*Details"/>   </context:component-scan> 
The <exclude-filter> and <include-filter> elements define a type attribute that specifies the strategy used for filtering component classes, and the expression attribute specifies the corresponding filter expression.


@Autowired - autowiring dependencies by type 
Spring’s @Autowired annotation provides the same functionality as the Spring’s autowiring feature that we discussed in chapter 4, but @Autowired annotation offers a more cleaner and flexible approach to autowiring bean dependencies.

@Autowired
private AccountStatementDao accountStatementDao;

In the above example listing, the accountStatementDao field (of type AccountStatementDao) is annotated with @Autowired annotation.
When an instance of AccountStatementServiceImpl is created, Spring’s
AutowiredAnnotationBeanPostProcessor (a BeanPostProcessor implementation) is responsible for autowiring accountStatementDao field.

If a method is annotated with @Autowired annotation, the arguments of the method are autowired. 
As obtainCustomerRegistrationDetails method is annotated with @Autowired annotation, its CustomerRegistrationDetails argument is autowired by type. 
It is important to note that an @Autowired annotated method need not be public. 

If a constructor is annotated with @Autowired annotation, the arguments of the constructor are autowired.

When using the @Autowired annotation, exception is thrown if a bean matching the required type is not found.

@Autowired’s required attribute specifies whether it is mandatory or optional to autowire dependencies. 
If you set @Autowired’s required attribute value to false, autowiring of dependencies is considered optional.

A component class can define multiple @Autowired annotated constructors with required attribute’s value set to false. In such a case, one of the constructors will be invoked by Spring to create an instance of the component class.
@Autowired(required=false)

The constructor with the largest number of satisfied dependencies is chosen.

@Qualifier – autowiring dependencies by name 

You can use Spring’s @Qualifier annotation along with @Autowired annotation to autowire dependencies by name. 
The @Qualifier annotation can be used at field-level, method-parameter-level and constructor-argument-level. 

@Autowired
@Qualifier(value="myFixedDepositDao")
private FixedDepositDao myFixedDepositDao;
n the above example listing, myFixedDepositDao field is annotated with @Autowired and @Qualifier annotations. @Qualifier annotation’s value attribute specifies the name of the bean to be assigned to the myFixedDepositDao field. 

Spring first finds autowiring candidates ‘by type’ for the fields, constructors and methods that are annotated with @Autowired annotation.
 Then, Spring uses the bean name specified by @Qualifier annotation to locate a unique bean from the list of autowiring candidates.

 @Qualifier(value="myFixedDepositDao") is same as @Qualifier("myFixedDepositDao"); you don’t need to use the value attribute to specify the name of the bean to be autowired. 

 Qualifier as a method parameter:

 @Autowiredpublic Sample(@Qualifier("aBean") ABean bean) { .... }

 JSR 330’s @Inject and @Named annotations 