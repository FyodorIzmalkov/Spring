Singleton

    <bean id="helloWorld" class="HelloWorld" scope="singleton">
        <property name="message" value="Hello world!" />
    </bean>

The prototype scope
If the scope is set to prototype, the Spring IoC container creates a new bean instance of the object every time a request 
for that specific bean is made. As a rule, use the prototype scope for all state-full beans and the singleton scope for stateless beans.

    <bean id="helloWorld" class="HelloWorld" scope="prototype">
        <property name="message" value="Hello world!" />
    </bean>

The life cycle of a Spring bean is easy to understand. When a bean is instantiated, 
it may be required to perform some initialization to get it into a usable state. 
Similarly, when the bean is no longer required and is removed from the container, some cleanup may be required.

To define setup and teardown for a bean, we simply declare the <bean> with initmethod and/or destroy-method parameters. 
The init-method attribute specifies a method that is to be called on the bean immediately upon instantiation. 
Similarly, destroymethod specifies a method that is called just before a bean is removed from the container.

AbstractApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
      HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
      obj.getMessage();
      context.registerShutdownHook();

Following is the content of the MainApp.java file. 
Here you need to register a shutdown hook registerShutdownHook() method that is declared on the AbstractApplicationContext class. 
This will ensure a graceful shutdown and call the relevant destroy methods.

If you have too many beans having initialization and/or destroy methods with the same name, you don't need to declare init-method and destroy-method on each individual bean. 
Instead, the framework provides the flexibility to configure such situation using default-init-method and default-destroy-method attributes on the <beans> element as follows −

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"
   default-init-method = "init" 
   default-destroy-method = "destroy">

   <bean id = "..." class = "...">
      <!-- collaborators and configuration for this bean go here -->
   </bean>
   
</beans>

The BeanPostProcessor interface defines callback methods that you can implement to provide your own instantiation logic, dependency-resolution logic, etc. 
You can also implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean by plugging in one or more BeanPostProcessor implementations.

You can configure multiple BeanPostProcessor interfaces and you can control the order in which these BeanPostProcessor interfaces execute 
by setting the order property provided the BeanPostProcessor implements the Ordered interface.

The BeanPostProcessors operate on bean (or object) instances, which means that the Spring IoC container instantiates a bean instance and then BeanPostProcessor interfaces do their work.

An ApplicationContext automatically detects any beans that are defined with the implementation of the 
BeanPostProcessor interface and registers these beans as postprocessors, to be then called appropriately by the container upon bean creation.

Мы можем применять что то к нашим бинам до и после инициализации бина

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class InitHelloWorld implements BeanPostProcessor {
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException{
        System.out.println("Before initialization: " + beanName);
        return bean;
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException{
        System.out.println("After initialization: " + beanName);
        return bean;
    }
}

первая функция выполнится до метода init вторая выполнится после того как метод init отработает

Constructor-based DI is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on the other class.
    
    <bean id="textEditor" class="TextEditor">
        <constructor-arg ref="spellChecker"></constructor-arg>
    </bean>

    <bean id="spellChecker" class="SpellChecker"></bean>

There may be an ambiguity while passing arguments to the constructor, in case there are more than one parameters. 
To resolve this ambiguity, the order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor. 
Consider the following class −
public class Foo {
   public Foo(Bar bar, Baz baz) {
      // ...
   }
}
The following configuration works fine −
<beans>
   <bean id = "foo" class = "x.y.Foo">
      <constructor-arg ref = "bar"/>
      <constructor-arg ref = "baz"/>
   </bean>

   <bean id = "bar" class = "x.y.Bar"/>
   <bean id = "baz" class = "x.y.Baz"/>
</beans>

Let us check one more case where we pass different types to the constructor. Consider the following class −
public class Foo {
   public Foo(int year, String name) {
      // ...
   }
}
The container can also use type matching with simple types, if you explicitly specify the type of the constructor argument using the type attribute. For example −
<beans>

   <bean id = "exampleBean" class = "examples.ExampleBean">
      <constructor-arg type = "int" value = "2001"/>
      <constructor-arg type = "java.lang.String" value = "Zara"/>
   </bean>

</beans>

Finally, the best way to pass constructor arguments, use the index attribute to specify explicitly the index of constructor arguments. Here, the index is 0 based. For example −

<beans>

   <bean id = "exampleBean" class = "examples.ExampleBean">
      <constructor-arg index = "0" value = "2001"/>
      <constructor-arg index = "1" value = "Zara"/>
   </bean>

</beans>

A final note, in case you are passing a reference to an object, you need to use ref attribute of <constructor-arg> 
tag and if you are passing a value directly then you should use value attribute as shown above.

Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.
   // a setter method to inject the dependency.
    public void setSpellChecker(SpellChecker spellChecker) {
        System.out.println("Inside setSpellChecker." );
        this.spellChecker = spellChecker;
    }
    Here you need to check the naming convention of the setter methods. To set a variable spellChecker we are using setSpellChecker() method which is very similar to Java POJO classes.

    <bean id="textEditor" class="TextEditor">
        <property name="spellChecker" ref="spellChecker"></property>
    </bean>

    <bean id="spellChecker" class="SpellChecker"></bean>

    If you have many setter methods, then it is convenient to use p-namespace in the XML configuration file. Let us check the difference −

    <bean id = "john-classic" class = "com.example.Person">
      <property name = "name" value = "John Doe"/>
      <property name = "spouse" ref = "jane"/>
   </bean>

   <bean name = "jane" class = "com.example.Person">
      <property name = "name" value = "John Doe"/>
   </bean>

   The above XML configuration can be re-written in a cleaner way using p-namespace as follows −

    <bean id = "john-classic" class = "com.example.Person"
      p:name = "John Doe"
      p:spouse-ref = "jane"/>
   </bean>

   <bean name =" jane" class = "com.example.Person"
      p:name = "John Doe"/>
   </bean>

   Here, you should note the difference in specifying primitive values and object references with p-namespace. 
   The -ref part indicates that this is not a straight value but rather a reference to another bean.

A bean definition can contain a lot of configuration information, including constructor arguments, property values, and container-specific 
information such as initialization method, static factory method name, and so on.

A child bean definition inherits configuration data from a parent definition. The child definition can override some values, or add others, as needed.

Spring Bean definition inheritance has nothing to do with Java class inheritance but the inheritance concept is same.
You can define a parent bean definition as a template and other child beans can inherit the required configuration from the parent bean.

When you use XML-based configuration metadata, you indicate a child bean definition by using the parent attribute, specifying the parent bean as the value of this attribute.

Following is the configuration file Beans.xml where we defined "helloWorld" bean which has two properties message1 and message2. 
Next "helloIndia" bean has been defined as a child of "helloWorld" bean by using parent attribute. 
The child bean inherits message2 property as is, and overrides message1 property and introduces one more property message3.

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id = "helloWorld" class = "com.tutorialspoint.HelloWorld">
      <property name = "message1" value = "Hello World!"/>
      <property name = "message2" value = "Hello Second World!"/>
   </bean>

   <bean id ="helloIndia" class = "com.tutorialspoint.HelloIndia" parent = "helloWorld">
      <property name = "message1" value = "Hello India!"/>
      <property name = "message3" value = "Namaste India!"/>
   </bean>
</beans>

Бин хеллоИндия наследует от бина хеллоВорлд сообщение 2, и оверрайдит сообщение 1, также создает свое сообщение 3

You can create a Bean definition template, which can be used by other child bean definitions without putting much effort. 
While defining a Bean Definition Template, you should not specify the class attribute and should specify abstract attribute and should specify the abstract attribute with a value of true

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id = "beanTeamplate" abstract = "true">
      <property name = "message1" value = "Hello World!"/>
      <property name = "message2" value = "Hello Second World!"/>
      <property name = "message3" value = "Namaste India!"/>
   </bean>

   <bean id = "helloIndia" class = "com.tutorialspoint.HelloIndia" parent = "beanTeamplate">
      <property name = "message1" value = "Hello India!"/>
      <property name = "message3" value = "Namaste India!"/>
   </bean>
   
</beans>

The parent bean cannot be instantiated on its own because it is incomplete, and it is also explicitly marked as abstract. 
When a definition is abstract like this, it is usable only as a pure template bean definition that serves as a parent definition for child definitions.

Every Java-based application has a few objects that work together to present what the end-user sees as a working application. 
When writing a complex Java application, application classes should be as independent as possible of other Java classes to increase the possibility 
to reuse these classes and to test them independently of other classes while unit testing. Dependency Injection (or sometime called wiring) helps in gluing these 
classes together and at the same time keeping them independent.

In an inversion of control scenario, we would instead do something like this −
public class TextEditor {
   private SpellChecker spellChecker;
   
   public TextEditor(SpellChecker spellChecker) {
      this.spellChecker = spellChecker;
   }
}
Here, the TextEditor should not worry about SpellChecker implementation. 
The SpellChecker will be implemented independently and will be provided to the TextEditor at the time of TextEditor instantiation. 
This entire procedure is controlled by the Spring Framework.

Here, we have removed total control from the TextEditor and kept it somewhere else (i.e. XML configuration file) and 
the dependency (i.e. class SpellChecker) is being injected into the class TextEditor through a Class Constructor. 
Thus the flow of control has been "inverted" by Dependency Injection (DI) because you have effectively delegated dependances to some external system.

The second method of injecting dependency is through Setter Methods of the TextEditor class where we will create a SpellChecker instance. 
This instance will be used to call setter methods to initialize TextEditor's properties.

	Dependency Injection Type  Description
1	Constructor-based dependency injection
Constructor-based DI is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on the other class.

2	Setter-based dependency injection
Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.

You can mix both, Constructor-based and Setter-based DI but it is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies.

The code is cleaner with the DI principle and decoupling is more effective when objects are provided with their dependencies. 
The object does not look up its dependencies and does not know the location or class of the dependencies, rather everything is taken care by the Spring Framework.

As you know Java inner classes are defined within the scope of other classes, similarly, inner beans are beans that are defined within the scope of another bean. 
Thus, a <bean/> element inside the <property/> or <constructor-arg/> elements is called inner bean and it is shown below.

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id = "outerBean" class = "...">
      <property name = "target">
         <bean id = "innerBean" class = "..."/>
      </property>
   </bean>

</beans>

Element & Description
1	
<list>

This helps in wiring ie injecting a list of values, allowing duplicates.

2	
<set>

This helps in wiring a set of values but without any duplicates.

3	
<map>

This can be used to inject a collection of name-value pairs where name and value can be of any type.

4	
<props>

This can be used to inject a collection of name-value pairs where the name and value are both Strings.

You will come across two situations (a) Passing direct values of the collection and (b) Passing a reference of a bean as one of the collection elements.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Definition for javaCollection -->
    <bean id="javaCollection" class="JavaCollection">
        <!-- results in a setAddressList(java.util.List) call -->
        <property name="addressList">
            <list>
                <value>INDIA</value>
                <value>Pakistan</value>
                <value>USA</value>
                <value>USA</value>
            </list>
        </property>

        <!-- results in a setAddressSet(java.util.Set) call -->
        <property name="addressSet">
            <set>
                <value>INDIA</value>
                <value>Pakistan</value>
                <value>USA</value>
                <value>USA</value>
            </set>
        </property>

        <!-- results in a setAddressMap(java.util.Map) call -->
        <property name = "addressMap">
            <map>
                <entry key = "1" value = "INDIA"/>
                <entry key = "2" value = "Pakistan"/>
                <entry key = "3" value = "USA"/>
                <entry key = "4" value = "USA"/>
            </map>
        </property>

        <!-- results in a setAddressProp(java.util.Properties) call -->
        <property name = "addressProp">
            <props>
                <prop key = "one">INDIA</prop>
                <prop key = "one">INDIA</prop>
                <prop key = "two">Pakistan</prop>
                <prop key = "three">USA</prop>
                <prop key = "four">USA</prop>
            </props>
        </property>
    </bean>

</beans>

Injecting Bean References
The following Bean definition will help you understand how to inject bean references as one of the collection's element. 
Even you can mix references and values all together as shown in the following code snippet −

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <!-- Bean Definition to handle references and values -->
   <bean id = "..." class = "...">

      <!-- Passing bean reference  for java.util.List -->
      <property name = "addressList">
         <list>
            <ref bean = "address1"/>
            <ref bean = "address2"/>
            <value>Pakistan</value>
         </list>
      </property>
      
      <!-- Passing bean reference  for java.util.Set -->
      <property name = "addressSet">
         <set>
            <ref bean = "address1"/>
            <ref bean = "address2"/>
            <value>Pakistan</value>
         </set>
      </property>
      
      <!-- Passing bean reference  for java.util.Map -->
      <property name = "addressMap">
         <map>
            <entry key = "one" value = "INDIA"/>
            <entry key = "two" value-ref = "address1"/>
            <entry key = "three" value-ref = "address2"/>
         </map>
      </property>
   </bean>

</beans>

To use the above bean definition, you need to define your setter methods in such a way that they should be able to handle references as well.

If you need to pass an empty string as a value, then you can pass it as follows −
<bean id = "..." class = "exampleBean">
   <property name = "email" value = ""/>
</bean>

The preceding example is equivalent to the Java code: exampleBean.setEmail("")

If you need to pass a NULL value, then you can pass it as follows −
<bean id = "..." class = "exampleBean">
   <property name = "email"><null/></property>
</bean>


The Spring container can autowire relationships between collaborating beans without using <constructor-arg> and <property> elements, 
which helps cut down on the amount of XML configuration you write for a big Spring-based application.

Following are the autowiring modes, which can be used to instruct the Spring container to use autowiring for dependency injection. 
You use the autowire attribute of the <bean/> element to specify autowire mode for a bean definition.

1	no
This is default setting which means no autowiring and you should use explicit bean reference for wiring. 
You have nothing to do special for this wiring. This is what you already have seen in Dependency Injection chapter.

2	byName
Autowiring by property name. Spring container looks at the properties of the beans on which autowire attribute is set to byName in the XML configuration file. 
It then tries to match and wire its properties with the beans defined by the same names in the configuration file.

3	byType
Autowiring by property datatype. Spring container looks at the properties of the beans on which autowire attribute is set to byType in the XML configuration file. 
It then tries to match and wire a property if its type matches with exactly one of the beans name in configuration file. If more than one such beans exists, a fatal exception is thrown.

4	constructor
Similar to byType, but type applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.

5	autodetect
Spring first tries to wire using autowire by constructor, if it does not work, Spring tries to autowire by byType.

You can use byType or constructor autowiring mode to wire arrays and other typed-collections.

Limitations with autowiring
Autowiring works best when it is used consistently across a project. 
If autowiring is not used in general, it might be confusing for developers to use it to wire only one or two bean definitions. 
Though, autowiring can significantly reduce the need to specify properties or constructor arguments but you should consider the limitations and disadvantages of autowiring before using them.

1	Overriding possibility

You can still specify dependencies using <constructor-arg> and <property> settings which will always override autowiring.

2	Primitive data types

You cannot autowire so-called simple properties such as primitives, Strings, and Classes.

3	Confusing nature

Autowiring is less exact than explicit wiring, so if possible prefer using explict wiring.

Starting from Spring 2.5 it became possible to configure the dependency injection using annotations. 
So instead of using XML to describe a bean wiring, you can move the bean configuration into the component class itself by using annotations on the relevant class, method, or field declaration.

Annotation injection is performed before XML injection. Thus, the latter configuration will override the former for properties wired through both approaches.

Annotation wiring is not turned on in the Spring container by default. 
So, before we can use annotation-based wiring, we will need to enable it in our Spring configuration file. 
So consider the following configuration file in case you want to use any annotation in your Spring application.

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context = "http://www.springframework.org/schema/context"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

   <context:annotation-config/>
   <!-- bean definitions go here -->
</beans>

Once <context:annotation-config/> is configured, you can start annotating your code to indicate that 
Spring should automatically wire values into properties, methods, and constructors. Let us look at a few important annotations to understand how they work −

1	@Required
The @Required annotation applies to bean property setter methods.
and it indicates that the affected bean property must be populated in XML configuration file at configuration time. 
Otherwise, the container throws a BeanInitializationException exception.

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context = "http://www.springframework.org/schema/context"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

   <context:annotation-config/>

   <!-- Definition for student bean -->
   <bean id = "student" class = "com.tutorialspoint.Student">
      <property name = "name" value = "Zara" />
      <property name = "age"  value = "11"/>
   </bean>

</beans>

2	@Autowired
The @Autowired annotation can apply to bean property setter methods, non-setter methods, constructor and properties.
The @Autowired annotation provides more fine-grained control over where and how autowiring should be accomplished. 
The @Autowired annotation can be used to autowire bean on the setter method just like @Required annotation, constructor, a property or methods with arbitrary names and/or multiple arguments.

You can use @Autowired annotation on setter methods to get rid of the <property> element in XML configuration file. 
When Spring finds an @Autowired annotation used with setter methods, it tries to perform byType autowiring on the method.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <!-- Definition for textEditor bean without constructor-arg  -->
    <bean id = "textEditor" class = "TextEditor"></bean>

    <!-- Definition for spellChecker bean -->
    <bean id = "spellChecker" class = "SpellChecker"></bean>

</beans>

You can use @Autowired annotation on properties to get rid of the setter methods. 
When you will pass values of autowired properties using <property> Spring will automatically assign those properties with the passed values or references.

public class TextEditor {
    @Autowired
    private SpellChecker spellChecker;
Задаем автовайрд на свойства и нам не нужны сеттеры

You can apply @Autowired to constructors as well. 
A constructor @Autowired annotation indicates that the constructor should be autowired when creating the bean, 
even if no <constructor-arg> elements are used while configuring the bean in XML file.

    @Autowired
    public TextEditor(SpellChecker spellChecker){
        System.out.println("Inside the TextEditor constructor");
        this.spellChecker = spellChecker;
    }

By default, the @Autowired annotation implies the dependency is required similar to @Required annotation, 
however, you can turn off the default behavior by using (required=false) option with @Autowired.

3	@Qualifier
The @Qualifier annotation along with @Autowired can be used to remove the confusion by specifiying which exact bean will be wired.
There may be a situation when you create more than one bean of the same type and want to wire only one of them with a property. 
In such cases, you can use the @Qualifier annotation along with @Autowired to remove the confusion by specifying which exact bean will be wired.

    <context:annotation-config/>

    <!-- Definition for profile bean -->
    <bean id="profile" class="Profile"></bean>

    <!-- Definition for student1 bean -->
    <bean id="student1" class="Student">
        <property name="age" value="11"></property>
        <property name="name" value="Zara" />
    </bean>

    <!-- Definition for student2 bean -->
    <bean id = "student2" class = "Student">
        <property name = "name" value = "Nuha" />
        <property name = "age" value = "2"/>
    </bean>

    public class Profile {
    @Autowired
    @Qualifier("student1")
    private Student student;

4	JSR-250 Annotations
Spring supports JSR-250 based annotations which include @Resource, @PostConstruct and @PreDestroy annotations.
To define the setup and teardown for a bean, we simply declare the <bean> with init-method and/or destroy-method parameters. 
The init-method attribute specifies a method that is to be called on the bean immediately upon instantiation. 
Similarly, the destroy-method specifies a method that is called just before a bean is removed from the container.
You can use @PostConstruct annotation as an alternate of initialization callback and @PreDestroy annotation as an alternate of destruction callback.

Java Based Configuration
So far you have seen how we configure Spring beans using XML configuration file. 
If you are comfortable with XML configuration, then it is really not required to learn how to proceed with 
Java-based configuration as you are going to achieve the same result using either of the configurations available.

Java-based configuration option enables you to write most of your Spring configuration without XML but with the help of few Java-based annotations explained in this chapter.

Annotating a class with the @Configuration indicates that the class can be used by the Spring IoC container as a source of bean definitions. 
The @Bean annotation tells Spring that a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context. 
The simplest possible @Configuration class would be as follows −
@Configuration
public class HelloWorldConfig {
   @Bean 
   public HelloWorld helloWorld(){
      return new HelloWorld();
   }
}

The above code will be equivalent to the following XML configuration −
<beans>
   <bean id = "helloWorld" class = "com.tutorialspoint.HelloWorld" />
</beans>

Here, the method name is annotated with @Bean works as bean ID and it creates and returns the actual bean. 
Your configuration class can have a declaration for more than one @Bean. 
Once your configuration classes are defined, you can load and provide them to Spring container using AnnotationConfigApplicationContext as follows −

public static void main(String[] args) {
   ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfig.class);
   
   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);
   helloWorld.setMessage("Hello World!");
   helloWorld.getMessage();
}

You can load various configuration classes as follows −
public static void main(String[] args) {
   AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();

   ctx.register(AppConfig.class, OtherConfig.class);
   ctx.register(AdditionalConfig.class);
   ctx.refresh();

   MyService myService = ctx.getBean(MyService.class);
   myService.doStuff();
}

Injecting Bean Dependencies
When @Beans have dependencies on one another, expressing that the dependency is as simple as having one bean method calling another as follows −
@Configuration
public class AppConfig {

    @Bean
    public Foo foo() {
        return new Foo(bar());
    }
    @Bean
    public Bar bar() {
        return new Bar();
    }
}

@Configuration
public class TextEditorConfig {
    @Bean
    public TextEditor textEditor(){
        return new TextEditor( spellChecker());
    }

    @Bean
    public SpellChecker spellChecker(){
        return new SpellChecker();
    }
}

The @Import Annotation
The @Import annotation allows for loading @Bean definitions from another configuration class. Consider a ConfigA class as follows −
@Configuration
public class ConfigA {
   @Bean
   public A a() {
      return new A(); 
   }
}

You can import above Bean declaration in another Bean Declaration as follows −
@Configuration
@Import(ConfigA.class)
public class ConfigB {
   @Bean
   public B b() {
      return new B(); 
   }
}
Now, rather than needing to specify both ConfigA.class and ConfigB.class when instantiating the context, only ConfigB needs to be supplied as follows −
ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);
   
   // now both beans A and B will be available...
   A a = ctx.getBean(A.class);
   B b = ctx.getBean(B.class);

   Lifecycle Callbacks
The @Bean annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML's init-method and destroy-method attributes on the bean element −
public class Foo {
   public void init() {
      // initialization logic
   }
   public void cleanup() {
      // destruction logic
   }
}
@Configuration
public class AppConfig {
   @Bean(initMethod = "init", destroyMethod = "cleanup" )
   public Foo foo() {
      return new Foo();
   }
}

Specifying Bean Scope
The default scope is singleton, but you can override this with the @Scope annotation as follows −

@Configuration
public class AppConfig {
   @Bean
   @Scope("prototype")
   public Foo foo() {
      return new Foo();
   }
}

Event Handling in Spring
The ApplicationContext publishes certain types of events when loading the beans. 
For example, a ContextStartedEvent is published when the context is started and ContextStoppedEvent is published when the context is stopped.

Event handling in the ApplicationContext is provided through the ApplicationEvent class and ApplicationListener interface.
Hence, if a bean implements the ApplicationListener, then every time an ApplicationEvent gets published to the ApplicationContext, that bean is notified.

Spring Built-in Events & Description
1	ContextRefreshedEvent
This event is published when the ApplicationContext is either initialized or refreshed. This can also be raised using the refresh() method on the ConfigurableApplicationContext interface.

2	ContextStartedEvent
This event is published when the ApplicationContext is started using the start() method on the ConfigurableApplicationContext interface.
You can poll your database or you can restart any stopped application after receiving this event.

3	ContextStoppedEvent
This event is published when the ApplicationContext is stopped using the stop() method on the ConfigurableApplicationContext interface.
You can do required housekeep work after receiving this event.

4	ContextClosedEvent
This event is published when the ApplicationContext is closed using the close() method on the ConfigurableApplicationContext interface. 
A closed context reaches its end of life; it cannot be refreshed or restarted.

5	RequestHandledEvent
This is a web-specific event telling all beans that an HTTP request has been serviced.

Spring's event handling is single-threaded so if an event is published, until and unless all the receivers get the message, the processes are blocked and the flow will not continue. 
Hence, care should be taken when designing your application if the event handling is to be used.

Listening to Context Events
To listen to a context event, a bean should implement the ApplicationListener interface which has just one method onApplicationEvent().

public class CStartEventHandler implements ApplicationListener<ContextStartedEvent> {
    public void onApplicationEvent(ContextStartedEvent event){
        System.out.println("ContextStartedEvent Received");
    }
}

    public static void main(String[] args) {
        ConfigurableApplicationContext context = new ClassPathXmlApplicationContext("spring-config.xml");

        // Let us raise a start event.
        context.start();

        HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
        obj.getMessage();

        // Let us raise a stop event.
        context.stop();
    }

    One of the key components of Spring Framework is the Aspect oriented programming (AOP) framework.
Aspect-Oriented Programming entails breaking down program logic into distinct parts called so-called concerns.
The functions that span multiple points of an application are called cross-cutting concerns and these cross-cutting 
concerns are conceptually separate from the application's business logic. There are various common good examples of aspects 
like logging, auditing, declarative transactions, security, caching, etc.

The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect. 
Dependency Injection helps you decouple your application objects from each other and AOP helps you 
decouple cross-cutting concerns from the objects that they affect. AOP is like triggers in programming 
languages such as Perl, .NET, Java, and others.

Spring AOP module provides interceptors to intercept an application. For example, when a method is executed, you can add extra functionality before or after the method execution.

AOP Terminologies
Before we start working with AOP, let us become familiar with the AOP concepts and terminology. These terms are not specific to Spring, rather they are related to AOP.

1	Aspect
This is a module which has a set of APIs providing cross-cutting requirements. 
For example, a logging module would be called AOP aspect for logging. An application can have any number of aspects depending on the requirement.

2	Join point
This represents a point in your application where you can plug-in the AOP aspect. 
You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework.

3	Advice
This is the actual action to be taken either before or after the method execution. 
This is an actual piece of code that is invoked during the program execution by Spring AOP framework.

4	Pointcut
This is a set of one or more join points where an advice should be executed. 
You can specify pointcuts using expressions or patterns as we will see in our AOP examples.

5	Introduction
An introduction allows you to add new methods or attributes to the existing classes.

6	Target object
The object being advised by one or more aspects. 
This object will always be a proxied object, also referred to as the advised object.

7	Weaving
Weaving is the process of linking aspects with other application types or objects to create an advised object. 
This can be done at compile time, load time, or at runtime.

Types of Advice
Spring aspects can work with five kinds of advice mentioned as follows −

1	before
Run advice before the a method execution.

2	after
Run advice after the method execution, regardless of its outcome.

3	after-returning
Run advice after the a method execution only if method completes successfully.

4	after-throwing
Run advice after the a method execution only if method exits by throwing an exception.

5	around
Run advice before and after the advised method is invoked.

Custom Aspects Implementation
Spring supports the @AspectJ annotation style approach and the schema-based approach to implement custom aspects. 

To use the AOP namespace tags described in this section, you need to import the springAOP schema as described −
<?xml version = "1.0" encoding = "UTF-8"?>
<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance" 
   xmlns:aop = "http://www.springframework.org/schema/aop"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
   http://www.springframework.org/schema/aop 
   http://www.springframework.org/schema/aop/spring-aop-3.0.xsd ">

   <!-- bean definition & AOP specific configuration -->

</beans>

Declaring an aspect
An aspect is declared using the <aop:aspect> element, and the backing bean is referenced using the ref attribute as follows −
<aop:config>
   <aop:aspect id = "myAspect" ref = "aBean">
      ...
   </aop:aspect>
</aop:config>

<bean id = "aBean" class = "...">
   ...
</bean>

A pointcut helps in determining the join points (ie methods) of interest to be executed with different advices. 
While working with XML Schema-based configuration, pointcut will be defined as follows −
<aop:config>
   <aop:aspect id = "myAspect" ref = "aBean">
      <aop:pointcut id = "businessService" 
         expression = "execution(*com.xyz.myapp.service.*.*(..))"/>
         ...
   </aop:aspect>
</aop:config>

The following example defines a pointcut named 'businessService' that will match the execution of getName() method available in the Student class under the package com.tutorialspoint −
<aop:config>
   <aop:aspect id = "myAspect" ref = "aBean">
      <aop:pointcut id = "businessService" 
         expression = "execution(*com.tutorialspoint.Student.getName(..))"/>
         ...
   </aop:aspect>
</aop:config>

You can declare any of the five advices inside an <aop:aspect> using the <aop:{ADVICE NAME}> element as given below −
<aop:config>
   <aop:aspect id = "myAspect" ref = "aBean">
      <aop:pointcut id = "businessService"
         expression = "execution(* com.xyz.myapp.service.*.*(..))"/>

      <!-- a before advice definition -->
      <aop:before pointcut-ref = "businessService" method = "doRequiredTask"/>

      <!-- an after advice definition -->
      <aop:after pointcut-ref = "businessService" method = "doRequiredTask"/>

      <!-- an after-returning advice definition -->
      <!--The doRequiredTask method must have parameter named retVal -->
      <aop:after-returning pointcut-ref = "businessService"
         returning = "retVal" method = "doRequiredTask"/>

      <!-- an after-throwing advice definition -->
      <!--The doRequiredTask method must have parameter named ex -->
      <aop:after-throwing pointcut-ref = "businessService"
         throwing = "ex" method = "doRequiredTask"/>

      <!-- an around advice definition -->
      <aop:around pointcut-ref = "businessService" method = "doRequiredTask"/>
      ...
   </aop:aspect>
</aop:config>

<bean id = "aBean" class = "...">
  ...
</bean>

@AspectJ refers to a style of declaring aspects as regular Java classes annotated with Java 5 annotations. 
The @AspectJ support is enabled by including the following element inside your XML Schema-based configuration file.
<aop:aspectj-autoproxy/>

Declaring an aspect
Aspects classes are like any other normal bean and may have methods and fields just like any other class, except that they will be annotated with @Aspect as follows −
@Aspect
public class AspectModule {
}
They will be configured in XML like any other bean as follows −
<bean id = "myAspect" class = "org.xyz.AspectModule">
   <!-- configure properties of aspect here as normal -->
</bean>

A pointcut helps in determining the join points (ie methods) of interest to be executed with different advices. While working with @AspectJ-based configuration, pointcut declaration has two parts −
A pointcut expression that determines exactly which method executions we are interested in.
A pointcut signature comprising a name and any number of parameters. 
The actual body of the method is irrelevant and in fact should be empty.

The following example defines a pointcut named 'businessService' that will match the execution of every method available in the classes under the package com.xyz.myapp.service −
@Pointcut("execution(* com.xyz.myapp.service.*.*(..))") // expression 
private void businessService() {}  // signature

The following example defines a pointcut named 'getname' that will match the execution of getName() method available in the Student class under the package com.tutorialspoint −
@Pointcut("execution(* com.tutorialspoint.Student.getName(..))") 
private void getname() {}

Declaring advices
You can declare any of the five advices using @{ADVICE-NAME} annotations as given in the code snippet. This assumes that you already have defined a pointcut signature method businessService() −
@Before("businessService()")
public void doBeforeTask(){
   ...
}

@After("businessService()")
public void doAfterTask(){
   ...
}

@AfterReturning(pointcut = "businessService()", returning = "retVal")
public void doAfterReturnningTask(Object retVal) {
   // you can intercept retVal here.
   ...
}

@AfterThrowing(pointcut = "businessService()", throwing = "ex")
public void doAfterThrowingTask(Exception ex) {
  // you can intercept thrown exception here.
  ...
}

@Around("businessService()")
public void doAroundTask(){
   ...
}

You can define a pointcut inline for any of the advices. Following is an example to define inline pointcut for before advice −
@Before("execution(* com.xyz.myapp.service.*.*(..))")
public doBeforeTask(){
   ...
}

While working with the database using plain old JDBC, it becomes cumbersome to write unnecessary code to handle exceptions, opening and closing database connections, etc. 
However, Spring JDBC Framework takes care of all the low-level details starting from opening the connection, 
prepare and execute the SQL statement, process exceptions, handle transactions and finally close the connection.

So what you have to do is just define the connection parameters and specify the SQL statement to be executed and do the required work for each iteration while fetching data from the database.

Spring JDBC provides several approaches and correspondingly different classes to interface with the database. 
I'm going to take classic and the most popular approach which makes use of JdbcTemplate class of the framework. 
This is the central framework class that manages all the database communication and exception handling.

JdbcTemplate Class
The JDBC Template class executes SQL queries, updates statements, stores procedure calls, performs iteration over ResultSets, and extracts returned parameter values. 
It also catches JDBC exceptions and translates them to the generic, more informative, exception hierarchy defined in the org.springframework.dao package.

Instances of the JdbcTemplate class are threadsafe once configured. 
So you can configure a single instance of a JdbcTemplate and then safely inject this shared reference into multiple DAOs.

A common practice when using the JDBC Template class is to configure a DataSource in your Spring configuration file, 
and then dependency-inject that shared DataSource bean into your DAO classes, and the JdbcTemplate is created in the setter for the DataSource.

Now we need to supply a DataSource to the JDBC Template so it can configure itself to get database access.
 You can configure the DataSource in the XML file with a piece of code as shown in the following code snippet −
 <bean id = "dataSource" 
   class = "org.springframework.jdbc.datasource.DriverManagerDataSource">
   <property name = "driverClassName" value = "com.mysql.jdbc.Driver"/>
   <property name = "url" value = "jdbc:mysql://localhost:3306/TEST"/>
   <property name = "username" value = "root"/>
   <property name = "password" value = "password"/>
</bean>

Data Access Object (DAO)
DAO stands for Data Access Object, which is commonly used for database interaction. 
DAOs exist to provide a means to read and write data to the database and they should expose this functionality 
through an interface by which the rest of the application will access them.

The DAO support in Spring makes it easy to work with data access technologies like JDBC, Hibernate, JPA, or JDO in a consistent way.

Querying for an integer

String SQL = "select count(*) from Student";
int rowCount = jdbcTemplateObject.queryForInt( SQL );

Querying for a long

String SQL = "select count(*) from Student";
long rowCount = jdbcTemplateObject.queryForLong( SQL );

A simple query using a bind variable

String SQL = "select age from Student where id = ?";
int age = jdbcTemplateObject.queryForInt(SQL, new Object[]{10});

Querying for a String

String SQL = "select name from Student where id = ?";
String name = jdbcTemplateObject.queryForObject(SQL, new Object[]{10}, String.class);

Querying and returning an object

String SQL = "select * from Student where id = ?";
Student student = jdbcTemplateObject.queryForObject(
   SQL, new Object[]{10}, new StudentMapper());

public class StudentMapper implements RowMapper<Student> {
   public Student mapRow(ResultSet rs, int rowNum) throws SQLException {
      Student student = new Student();
      student.setID(rs.getInt("id"));
      student.setName(rs.getString("name"));
      student.setAge(rs.getInt("age"));
      
      return student;
   }
}

A database transaction is a sequence of actions that are treated as a single unit of work. These actions should either complete entirely or take no effect at all. 
Transaction management is an important part of RDBMS-oriented enterprise application to ensure data integrity and consistency. 
The concept of transactions can be described with the following four key properties described as ACID −
Atomicity − A transaction should be treated as a single unit of operation, which means either the entire sequence of operations is successful or unsuccessful.
Consistency − This represents the consistency of the referential integrity of the database, unique primary keys in tables, etc.
Isolation − There may be many transaction processing with the same data set at the same time. Each transaction should be isolated from others to prevent data corruption.
Durability − Once a transaction has completed, the results of this transaction have to be made permanent and cannot be erased from the database due to system failure.

A real RDBMS database system will guarantee all four properties for each transaction. The simplistic view of a transaction issued to the database using SQL is as follows −
    Begin the transaction using begin transaction command.
    Perform various deleted, update or insert operations using SQL queries.
    If all the operation are successful then perform commit otherwise rollback all the operations.

Spring framework provides an abstract layer on top of different underlying transaction management APIs. 
Spring's transaction support aims to provide an alternative to EJB transactions by adding transaction capabilities to POJOs.
 Spring supports both programmatic and declarative transaction management. EJBs require an application server, 
 but Spring transaction management can be implemented without the need of an application server.

 Local vs. Global Transactions
 Local transactions are specific to a single transactional resource like a JDBC connection, 
 whereas global transactions can span multiple transactional resources like transaction in a distributed system.