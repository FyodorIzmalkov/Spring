Singleton

    <bean id="helloWorld" class="HelloWorld" scope="singleton">
        <property name="message" value="Hello world!" />
    </bean>

The prototype scope
If the scope is set to prototype, the Spring IoC container creates a new bean instance of the object every time a request 
for that specific bean is made. As a rule, use the prototype scope for all state-full beans and the singleton scope for stateless beans.

    <bean id="helloWorld" class="HelloWorld" scope="prototype">
        <property name="message" value="Hello world!" />
    </bean>

The life cycle of a Spring bean is easy to understand. When a bean is instantiated, 
it may be required to perform some initialization to get it into a usable state. 
Similarly, when the bean is no longer required and is removed from the container, some cleanup may be required.

To define setup and teardown for a bean, we simply declare the <bean> with initmethod and/or destroy-method parameters. 
The init-method attribute specifies a method that is to be called on the bean immediately upon instantiation. 
Similarly, destroymethod specifies a method that is called just before a bean is removed from the container.

AbstractApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
      HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
      obj.getMessage();
      context.registerShutdownHook();

Following is the content of the MainApp.java file. 
Here you need to register a shutdown hook registerShutdownHook() method that is declared on the AbstractApplicationContext class. 
This will ensure a graceful shutdown and call the relevant destroy methods.

If you have too many beans having initialization and/or destroy methods with the same name, you don't need to declare init-method and destroy-method on each individual bean. 
Instead, the framework provides the flexibility to configure such situation using default-init-method and default-destroy-method attributes on the <beans> element as follows −

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"
   default-init-method = "init" 
   default-destroy-method = "destroy">

   <bean id = "..." class = "...">
      <!-- collaborators and configuration for this bean go here -->
   </bean>
   
</beans>

The BeanPostProcessor interface defines callback methods that you can implement to provide your own instantiation logic, dependency-resolution logic, etc. 
You can also implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean by plugging in one or more BeanPostProcessor implementations.

You can configure multiple BeanPostProcessor interfaces and you can control the order in which these BeanPostProcessor interfaces execute 
by setting the order property provided the BeanPostProcessor implements the Ordered interface.

The BeanPostProcessors operate on bean (or object) instances, which means that the Spring IoC container instantiates a bean instance and then BeanPostProcessor interfaces do their work.

An ApplicationContext automatically detects any beans that are defined with the implementation of the 
BeanPostProcessor interface and registers these beans as postprocessors, to be then called appropriately by the container upon bean creation.

Мы можем применять что то к нашим бинам до и после инициализации бина

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class InitHelloWorld implements BeanPostProcessor {
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException{
        System.out.println("Before initialization: " + beanName);
        return bean;
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException{
        System.out.println("After initialization: " + beanName);
        return bean;
    }
}

первая функция выполнится до метода init вторая выполнится после того как метод init отработает

A bean definition can contain a lot of configuration information, including constructor arguments, property values, and container-specific 
information such as initialization method, static factory method name, and so on.

A child bean definition inherits configuration data from a parent definition. The child definition can override some values, or add others, as needed.

Spring Bean definition inheritance has nothing to do with Java class inheritance but the inheritance concept is same.
You can define a parent bean definition as a template and other child beans can inherit the required configuration from the parent bean.

When you use XML-based configuration metadata, you indicate a child bean definition by using the parent attribute, specifying the parent bean as the value of this attribute.

Following is the configuration file Beans.xml where we defined "helloWorld" bean which has two properties message1 and message2. 
Next "helloIndia" bean has been defined as a child of "helloWorld" bean by using parent attribute. 
The child bean inherits message2 property as is, and overrides message1 property and introduces one more property message3.

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id = "helloWorld" class = "com.tutorialspoint.HelloWorld">
      <property name = "message1" value = "Hello World!"/>
      <property name = "message2" value = "Hello Second World!"/>
   </bean>

   <bean id ="helloIndia" class = "com.tutorialspoint.HelloIndia" parent = "helloWorld">
      <property name = "message1" value = "Hello India!"/>
      <property name = "message3" value = "Namaste India!"/>
   </bean>
</beans>

Бин хеллоИндия наследует от бина хеллоВорлд сообщение 2, и оверрайдит сообщение 1, также создает свое сообщение 3

You can create a Bean definition template, which can be used by other child bean definitions without putting much effort. 
While defining a Bean Definition Template, you should not specify the class attribute and should specify abstract attribute and should specify the abstract attribute with a value of true

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id = "beanTeamplate" abstract = "true">
      <property name = "message1" value = "Hello World!"/>
      <property name = "message2" value = "Hello Second World!"/>
      <property name = "message3" value = "Namaste India!"/>
   </bean>

   <bean id = "helloIndia" class = "com.tutorialspoint.HelloIndia" parent = "beanTeamplate">
      <property name = "message1" value = "Hello India!"/>
      <property name = "message3" value = "Namaste India!"/>
   </bean>
   
</beans>

The parent bean cannot be instantiated on its own because it is incomplete, and it is also explicitly marked as abstract. 
When a definition is abstract like this, it is usable only as a pure template bean definition that serves as a parent definition for child definitions.

Every Java-based application has a few objects that work together to present what the end-user sees as a working application. 
When writing a complex Java application, application classes should be as independent as possible of other Java classes to increase the possibility 
to reuse these classes and to test them independently of other classes while unit testing. Dependency Injection (or sometime called wiring) helps in gluing these 
classes together and at the same time keeping them independent.

In an inversion of control scenario, we would instead do something like this −
public class TextEditor {
   private SpellChecker spellChecker;
   
   public TextEditor(SpellChecker spellChecker) {
      this.spellChecker = spellChecker;
   }
}
Here, the TextEditor should not worry about SpellChecker implementation. 
The SpellChecker will be implemented independently and will be provided to the TextEditor at the time of TextEditor instantiation. 
This entire procedure is controlled by the Spring Framework.

Here, we have removed total control from the TextEditor and kept it somewhere else (i.e. XML configuration file) and 
the dependency (i.e. class SpellChecker) is being injected into the class TextEditor through a Class Constructor. 
Thus the flow of control has been "inverted" by Dependency Injection (DI) because you have effectively delegated dependances to some external system.

The second method of injecting dependency is through Setter Methods of the TextEditor class where we will create a SpellChecker instance. 
This instance will be used to call setter methods to initialize TextEditor's properties.

	Dependency Injection Type  Description
1	Constructor-based dependency injection
Constructor-based DI is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on the other class.

2	Setter-based dependency injection
Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.

You can mix both, Constructor-based and Setter-based DI but it is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies.

The code is cleaner with the DI principle and decoupling is more effective when objects are provided with their dependencies. 
The object does not look up its dependencies and does not know the location or class of the dependencies, rather everything is taken care by the Spring Framework.

As you know Java inner classes are defined within the scope of other classes, similarly, inner beans are beans that are defined within the scope of another bean. 
Thus, a <bean/> element inside the <property/> or <constructor-arg/> elements is called inner bean and it is shown below.

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id = "outerBean" class = "...">
      <property name = "target">
         <bean id = "innerBean" class = "..."/>
      </property>
   </bean>

</beans>

Element & Description
1	
<list>

This helps in wiring ie injecting a list of values, allowing duplicates.

2	
<set>

This helps in wiring a set of values but without any duplicates.

3	
<map>

This can be used to inject a collection of name-value pairs where name and value can be of any type.

4	
<props>

This can be used to inject a collection of name-value pairs where the name and value are both Strings.

You will come across two situations (a) Passing direct values of the collection and (b) Passing a reference of a bean as one of the collection elements.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Definition for javaCollection -->
    <bean id="javaCollection" class="JavaCollection">
        <!-- results in a setAddressList(java.util.List) call -->
        <property name="addressList">
            <list>
                <value>INDIA</value>
                <value>Pakistan</value>
                <value>USA</value>
                <value>USA</value>
            </list>
        </property>

        <!-- results in a setAddressSet(java.util.Set) call -->
        <property name="addressSet">
            <set>
                <value>INDIA</value>
                <value>Pakistan</value>
                <value>USA</value>
                <value>USA</value>
            </set>
        </property>

        <!-- results in a setAddressMap(java.util.Map) call -->
        <property name = "addressMap">
            <map>
                <entry key = "1" value = "INDIA"/>
                <entry key = "2" value = "Pakistan"/>
                <entry key = "3" value = "USA"/>
                <entry key = "4" value = "USA"/>
            </map>
        </property>

        <!-- results in a setAddressProp(java.util.Properties) call -->
        <property name = "addressProp">
            <props>
                <prop key = "one">INDIA</prop>
                <prop key = "one">INDIA</prop>
                <prop key = "two">Pakistan</prop>
                <prop key = "three">USA</prop>
                <prop key = "four">USA</prop>
            </props>
        </property>
    </bean>

</beans>