Singleton

    <bean id="helloWorld" class="HelloWorld" scope="singleton">
        <property name="message" value="Hello world!" />
    </bean>

The prototype scope
If the scope is set to prototype, the Spring IoC container creates a new bean instance of the object every time a request 
for that specific bean is made. As a rule, use the prototype scope for all state-full beans and the singleton scope for stateless beans.

    <bean id="helloWorld" class="HelloWorld" scope="prototype">
        <property name="message" value="Hello world!" />
    </bean>

The life cycle of a Spring bean is easy to understand. When a bean is instantiated, 
it may be required to perform some initialization to get it into a usable state. 
Similarly, when the bean is no longer required and is removed from the container, some cleanup may be required.

To define setup and teardown for a bean, we simply declare the <bean> with initmethod and/or destroy-method parameters. 
The init-method attribute specifies a method that is to be called on the bean immediately upon instantiation. 
Similarly, destroymethod specifies a method that is called just before a bean is removed from the container.

AbstractApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
      HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
      obj.getMessage();
      context.registerShutdownHook();

Following is the content of the MainApp.java file. 
Here you need to register a shutdown hook registerShutdownHook() method that is declared on the AbstractApplicationContext class. 
This will ensure a graceful shutdown and call the relevant destroy methods.

If you have too many beans having initialization and/or destroy methods with the same name, you don't need to declare init-method and destroy-method on each individual bean. 
Instead, the framework provides the flexibility to configure such situation using default-init-method and default-destroy-method attributes on the <beans> element as follows −

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"
   default-init-method = "init" 
   default-destroy-method = "destroy">

   <bean id = "..." class = "...">
      <!-- collaborators and configuration for this bean go here -->
   </bean>
   
</beans>

The BeanPostProcessor interface defines callback methods that you can implement to provide your own instantiation logic, dependency-resolution logic, etc. 
You can also implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean by plugging in one or more BeanPostProcessor implementations.

You can configure multiple BeanPostProcessor interfaces and you can control the order in which these BeanPostProcessor interfaces execute 
by setting the order property provided the BeanPostProcessor implements the Ordered interface.

The BeanPostProcessors operate on bean (or object) instances, which means that the Spring IoC container instantiates a bean instance and then BeanPostProcessor interfaces do their work.

An ApplicationContext automatically detects any beans that are defined with the implementation of the 
BeanPostProcessor interface and registers these beans as postprocessors, to be then called appropriately by the container upon bean creation.

Мы можем применять что то к нашим бинам до и после инициализации бина

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class InitHelloWorld implements BeanPostProcessor {
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException{
        System.out.println("Before initialization: " + beanName);
        return bean;
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException{
        System.out.println("After initialization: " + beanName);
        return bean;
    }
}

первая функция выполнится до метода init вторая выполнится после того как метод init отработает

A bean definition can contain a lot of configuration information, including constructor arguments, property values, and container-specific 
information such as initialization method, static factory method name, and so on.

A child bean definition inherits configuration data from a parent definition. The child definition can override some values, or add others, as needed.

Spring Bean definition inheritance has nothing to do with Java class inheritance but the inheritance concept is same.
You can define a parent bean definition as a template and other child beans can inherit the required configuration from the parent bean.

When you use XML-based configuration metadata, you indicate a child bean definition by using the parent attribute, specifying the parent bean as the value of this attribute.

Following is the configuration file Beans.xml where we defined "helloWorld" bean which has two properties message1 and message2. 
Next "helloIndia" bean has been defined as a child of "helloWorld" bean by using parent attribute. 
The child bean inherits message2 property as is, and overrides message1 property and introduces one more property message3.

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id = "helloWorld" class = "com.tutorialspoint.HelloWorld">
      <property name = "message1" value = "Hello World!"/>
      <property name = "message2" value = "Hello Second World!"/>
   </bean>

   <bean id ="helloIndia" class = "com.tutorialspoint.HelloIndia" parent = "helloWorld">
      <property name = "message1" value = "Hello India!"/>
      <property name = "message3" value = "Namaste India!"/>
   </bean>
</beans>

Бин хеллоИндия наследует от бина хеллоВорлд сообщение 2, и оверрайдит сообщение 1, также создает свое сообщение 3

You can create a Bean definition template, which can be used by other child bean definitions without putting much effort. 
While defining a Bean Definition Template, you should not specify the class attribute and should specify abstract attribute and should specify the abstract attribute with a value of true

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id = "beanTeamplate" abstract = "true">
      <property name = "message1" value = "Hello World!"/>
      <property name = "message2" value = "Hello Second World!"/>
      <property name = "message3" value = "Namaste India!"/>
   </bean>

   <bean id = "helloIndia" class = "com.tutorialspoint.HelloIndia" parent = "beanTeamplate">
      <property name = "message1" value = "Hello India!"/>
      <property name = "message3" value = "Namaste India!"/>
   </bean>
   
</beans>

The parent bean cannot be instantiated on its own because it is incomplete, and it is also explicitly marked as abstract. 
When a definition is abstract like this, it is usable only as a pure template bean definition that serves as a parent definition for child definitions.

Every Java-based application has a few objects that work together to present what the end-user sees as a working application. 
When writing a complex Java application, application classes should be as independent as possible of other Java classes to increase the possibility 
to reuse these classes and to test them independently of other classes while unit testing. Dependency Injection (or sometime called wiring) helps in gluing these 
classes together and at the same time keeping them independent.

In an inversion of control scenario, we would instead do something like this −
public class TextEditor {
   private SpellChecker spellChecker;
   
   public TextEditor(SpellChecker spellChecker) {
      this.spellChecker = spellChecker;
   }
}
Here, the TextEditor should not worry about SpellChecker implementation. 
The SpellChecker will be implemented independently and will be provided to the TextEditor at the time of TextEditor instantiation. 
This entire procedure is controlled by the Spring Framework.

Here, we have removed total control from the TextEditor and kept it somewhere else (i.e. XML configuration file) and 
the dependency (i.e. class SpellChecker) is being injected into the class TextEditor through a Class Constructor. 
Thus the flow of control has been "inverted" by Dependency Injection (DI) because you have effectively delegated dependances to some external system.

The second method of injecting dependency is through Setter Methods of the TextEditor class where we will create a SpellChecker instance. 
This instance will be used to call setter methods to initialize TextEditor's properties.

	Dependency Injection Type  Description
1	Constructor-based dependency injection
Constructor-based DI is accomplished when the container invokes a class constructor with a number of arguments, each representing a dependency on the other class.

2	Setter-based dependency injection
Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument static factory method to instantiate your bean.

You can mix both, Constructor-based and Setter-based DI but it is a good rule of thumb to use constructor arguments for mandatory dependencies and setters for optional dependencies.

The code is cleaner with the DI principle and decoupling is more effective when objects are provided with their dependencies. 
The object does not look up its dependencies and does not know the location or class of the dependencies, rather everything is taken care by the Spring Framework.

As you know Java inner classes are defined within the scope of other classes, similarly, inner beans are beans that are defined within the scope of another bean. 
Thus, a <bean/> element inside the <property/> or <constructor-arg/> elements is called inner bean and it is shown below.

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <bean id = "outerBean" class = "...">
      <property name = "target">
         <bean id = "innerBean" class = "..."/>
      </property>
   </bean>

</beans>

Element & Description
1	
<list>

This helps in wiring ie injecting a list of values, allowing duplicates.

2	
<set>

This helps in wiring a set of values but without any duplicates.

3	
<map>

This can be used to inject a collection of name-value pairs where name and value can be of any type.

4	
<props>

This can be used to inject a collection of name-value pairs where the name and value are both Strings.

You will come across two situations (a) Passing direct values of the collection and (b) Passing a reference of a bean as one of the collection elements.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Definition for javaCollection -->
    <bean id="javaCollection" class="JavaCollection">
        <!-- results in a setAddressList(java.util.List) call -->
        <property name="addressList">
            <list>
                <value>INDIA</value>
                <value>Pakistan</value>
                <value>USA</value>
                <value>USA</value>
            </list>
        </property>

        <!-- results in a setAddressSet(java.util.Set) call -->
        <property name="addressSet">
            <set>
                <value>INDIA</value>
                <value>Pakistan</value>
                <value>USA</value>
                <value>USA</value>
            </set>
        </property>

        <!-- results in a setAddressMap(java.util.Map) call -->
        <property name = "addressMap">
            <map>
                <entry key = "1" value = "INDIA"/>
                <entry key = "2" value = "Pakistan"/>
                <entry key = "3" value = "USA"/>
                <entry key = "4" value = "USA"/>
            </map>
        </property>

        <!-- results in a setAddressProp(java.util.Properties) call -->
        <property name = "addressProp">
            <props>
                <prop key = "one">INDIA</prop>
                <prop key = "one">INDIA</prop>
                <prop key = "two">Pakistan</prop>
                <prop key = "three">USA</prop>
                <prop key = "four">USA</prop>
            </props>
        </property>
    </bean>

</beans>

Injecting Bean References
The following Bean definition will help you understand how to inject bean references as one of the collection's element. 
Even you can mix references and values all together as shown in the following code snippet −

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

   <!-- Bean Definition to handle references and values -->
   <bean id = "..." class = "...">

      <!-- Passing bean reference  for java.util.List -->
      <property name = "addressList">
         <list>
            <ref bean = "address1"/>
            <ref bean = "address2"/>
            <value>Pakistan</value>
         </list>
      </property>
      
      <!-- Passing bean reference  for java.util.Set -->
      <property name = "addressSet">
         <set>
            <ref bean = "address1"/>
            <ref bean = "address2"/>
            <value>Pakistan</value>
         </set>
      </property>
      
      <!-- Passing bean reference  for java.util.Map -->
      <property name = "addressMap">
         <map>
            <entry key = "one" value = "INDIA"/>
            <entry key = "two" value-ref = "address1"/>
            <entry key = "three" value-ref = "address2"/>
         </map>
      </property>
   </bean>

</beans>

To use the above bean definition, you need to define your setter methods in such a way that they should be able to handle references as well.

If you need to pass an empty string as a value, then you can pass it as follows −
<bean id = "..." class = "exampleBean">
   <property name = "email" value = ""/>
</bean>

The preceding example is equivalent to the Java code: exampleBean.setEmail("")

If you need to pass a NULL value, then you can pass it as follows −
<bean id = "..." class = "exampleBean">
   <property name = "email"><null/></property>
</bean>


The Spring container can autowire relationships between collaborating beans without using <constructor-arg> and <property> elements, 
which helps cut down on the amount of XML configuration you write for a big Spring-based application.

Following are the autowiring modes, which can be used to instruct the Spring container to use autowiring for dependency injection. 
You use the autowire attribute of the <bean/> element to specify autowire mode for a bean definition.

1	no
This is default setting which means no autowiring and you should use explicit bean reference for wiring. 
You have nothing to do special for this wiring. This is what you already have seen in Dependency Injection chapter.

2	byName
Autowiring by property name. Spring container looks at the properties of the beans on which autowire attribute is set to byName in the XML configuration file. 
It then tries to match and wire its properties with the beans defined by the same names in the configuration file.

3	byType
Autowiring by property datatype. Spring container looks at the properties of the beans on which autowire attribute is set to byType in the XML configuration file. 
It then tries to match and wire a property if its type matches with exactly one of the beans name in configuration file. If more than one such beans exists, a fatal exception is thrown.

4	constructor
Similar to byType, but type applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.

5	autodetect
Spring first tries to wire using autowire by constructor, if it does not work, Spring tries to autowire by byType.

You can use byType or constructor autowiring mode to wire arrays and other typed-collections.

Limitations with autowiring
Autowiring works best when it is used consistently across a project. 
If autowiring is not used in general, it might be confusing for developers to use it to wire only one or two bean definitions. 
Though, autowiring can significantly reduce the need to specify properties or constructor arguments but you should consider the limitations and disadvantages of autowiring before using them.

1	Overriding possibility

You can still specify dependencies using <constructor-arg> and <property> settings which will always override autowiring.

2	Primitive data types

You cannot autowire so-called simple properties such as primitives, Strings, and Classes.

3	Confusing nature

Autowiring is less exact than explicit wiring, so if possible prefer using explict wiring.

Starting from Spring 2.5 it became possible to configure the dependency injection using annotations. 
So instead of using XML to describe a bean wiring, you can move the bean configuration into the component class itself by using annotations on the relevant class, method, or field declaration.

Annotation injection is performed before XML injection. Thus, the latter configuration will override the former for properties wired through both approaches.

Annotation wiring is not turned on in the Spring container by default. 
So, before we can use annotation-based wiring, we will need to enable it in our Spring configuration file. 
So consider the following configuration file in case you want to use any annotation in your Spring application.

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context = "http://www.springframework.org/schema/context"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

   <context:annotation-config/>
   <!-- bean definitions go here -->
</beans>

Once <context:annotation-config/> is configured, you can start annotating your code to indicate that 
Spring should automatically wire values into properties, methods, and constructors. Let us look at a few important annotations to understand how they work −

1	@Required
The @Required annotation applies to bean property setter methods.
and it indicates that the affected bean property must be populated in XML configuration file at configuration time. 
Otherwise, the container throws a BeanInitializationException exception.

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context = "http://www.springframework.org/schema/context"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

   <context:annotation-config/>

   <!-- Definition for student bean -->
   <bean id = "student" class = "com.tutorialspoint.Student">
      <property name = "name" value = "Zara" />
      <property name = "age"  value = "11"/>
   </bean>

</beans>

2	@Autowired
The @Autowired annotation can apply to bean property setter methods, non-setter methods, constructor and properties.
The @Autowired annotation provides more fine-grained control over where and how autowiring should be accomplished. 
The @Autowired annotation can be used to autowire bean on the setter method just like @Required annotation, constructor, a property or methods with arbitrary names and/or multiple arguments.

You can use @Autowired annotation on setter methods to get rid of the <property> element in XML configuration file. 
When Spring finds an @Autowired annotation used with setter methods, it tries to perform byType autowiring on the method.

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <!-- Definition for textEditor bean without constructor-arg  -->
    <bean id = "textEditor" class = "TextEditor"></bean>

    <!-- Definition for spellChecker bean -->
    <bean id = "spellChecker" class = "SpellChecker"></bean>

</beans>

You can use @Autowired annotation on properties to get rid of the setter methods. 
When you will pass values of autowired properties using <property> Spring will automatically assign those properties with the passed values or references.

public class TextEditor {
    @Autowired
    private SpellChecker spellChecker;
Задаем автовайрд на свойства и нам не нужны сеттеры

You can apply @Autowired to constructors as well. 
A constructor @Autowired annotation indicates that the constructor should be autowired when creating the bean, 
even if no <constructor-arg> elements are used while configuring the bean in XML file.

    @Autowired
    public TextEditor(SpellChecker spellChecker){
        System.out.println("Inside the TextEditor constructor");
        this.spellChecker = spellChecker;
    }

By default, the @Autowired annotation implies the dependency is required similar to @Required annotation, 
however, you can turn off the default behavior by using (required=false) option with @Autowired.

3	@Qualifier
The @Qualifier annotation along with @Autowired can be used to remove the confusion by specifiying which exact bean will be wired.
There may be a situation when you create more than one bean of the same type and want to wire only one of them with a property. 
In such cases, you can use the @Qualifier annotation along with @Autowired to remove the confusion by specifying which exact bean will be wired.

    <context:annotation-config/>

    <!-- Definition for profile bean -->
    <bean id="profile" class="Profile"></bean>

    <!-- Definition for student1 bean -->
    <bean id="student1" class="Student">
        <property name="age" value="11"></property>
        <property name="name" value="Zara" />
    </bean>

    <!-- Definition for student2 bean -->
    <bean id = "student2" class = "Student">
        <property name = "name" value = "Nuha" />
        <property name = "age" value = "2"/>
    </bean>

    public class Profile {
    @Autowired
    @Qualifier("student1")
    private Student student;

4	JSR-250 Annotations
Spring supports JSR-250 based annotations which include @Resource, @PostConstruct and @PreDestroy annotations.
To define the setup and teardown for a bean, we simply declare the <bean> with init-method and/or destroy-method parameters. 
The init-method attribute specifies a method that is to be called on the bean immediately upon instantiation. 
Similarly, the destroy-method specifies a method that is called just before a bean is removed from the container.
You can use @PostConstruct annotation as an alternate of initialization callback and @PreDestroy annotation as an alternate of destruction callback.

Java Based Configuration
So far you have seen how we configure Spring beans using XML configuration file. 
If you are comfortable with XML configuration, then it is really not required to learn how to proceed with 
Java-based configuration as you are going to achieve the same result using either of the configurations available.

Java-based configuration option enables you to write most of your Spring configuration without XML but with the help of few Java-based annotations explained in this chapter.

Annotating a class with the @Configuration indicates that the class can be used by the Spring IoC container as a source of bean definitions. 
The @Bean annotation tells Spring that a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context. 
The simplest possible @Configuration class would be as follows −
@Configuration
public class HelloWorldConfig {
   @Bean 
   public HelloWorld helloWorld(){
      return new HelloWorld();
   }
}

The above code will be equivalent to the following XML configuration −
<beans>
   <bean id = "helloWorld" class = "com.tutorialspoint.HelloWorld" />
</beans>

Here, the method name is annotated with @Bean works as bean ID and it creates and returns the actual bean. 
Your configuration class can have a declaration for more than one @Bean. 
Once your configuration classes are defined, you can load and provide them to Spring container using AnnotationConfigApplicationContext as follows −

public static void main(String[] args) {
   ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfig.class);
   
   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);
   helloWorld.setMessage("Hello World!");
   helloWorld.getMessage();
}

You can load various configuration classes as follows −
public static void main(String[] args) {
   AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();

   ctx.register(AppConfig.class, OtherConfig.class);
   ctx.register(AdditionalConfig.class);
   ctx.refresh();

   MyService myService = ctx.getBean(MyService.class);
   myService.doStuff();
}

Injecting Bean Dependencies
When @Beans have dependencies on one another, expressing that the dependency is as simple as having one bean method calling another as follows −
@Configuration
public class AppConfig {

    @Bean
    public Foo foo() {
        return new Foo(bar());
    }
    @Bean
    public Bar bar() {
        return new Bar();
    }
}

@Configuration
public class TextEditorConfig {
    @Bean
    public TextEditor textEditor(){
        return new TextEditor( spellChecker());
    }

    @Bean
    public SpellChecker spellChecker(){
        return new SpellChecker();
    }
}

The @Import Annotation
The @Import annotation allows for loading @Bean definitions from another configuration class. Consider a ConfigA class as follows −
@Configuration
public class ConfigA {
   @Bean
   public A a() {
      return new A(); 
   }
}

You can import above Bean declaration in another Bean Declaration as follows −
@Configuration
@Import(ConfigA.class)
public class ConfigB {
   @Bean
   public B b() {
      return new B(); 
   }
}
Now, rather than needing to specify both ConfigA.class and ConfigB.class when instantiating the context, only ConfigB needs to be supplied as follows −
ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);
   
   // now both beans A and B will be available...
   A a = ctx.getBean(A.class);
   B b = ctx.getBean(B.class);

   Lifecycle Callbacks
The @Bean annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML's init-method and destroy-method attributes on the bean element −
public class Foo {
   public void init() {
      // initialization logic
   }
   public void cleanup() {
      // destruction logic
   }
}
@Configuration
public class AppConfig {
   @Bean(initMethod = "init", destroyMethod = "cleanup" )
   public Foo foo() {
      return new Foo();
   }
}

Specifying Bean Scope
The default scope is singleton, but you can override this with the @Scope annotation as follows −

@Configuration
public class AppConfig {
   @Bean
   @Scope("prototype")
   public Foo foo() {
      return new Foo();
   }
}

Event Handling in Spring